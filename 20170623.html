<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
 <title>IRC log for #brlcad on 20170623</title>
 <meta name="generator" content="irclog2html.pl">
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body text="#000000" bgcolor="#ffffff">
<h1>IRC log for #brlcad on 20170623</h1>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Default -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-1563266826402652"
     data-ad-slot="5026919875"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
<form action="http://www.google.com" id="cse-search-box">
  <div>
    <input type="hidden" name="cx" value="partner-pub-1563266826402652:3301963896" />
    <input type="hidden" name="ie" value="UTF-8" />
    <input type="text" name="q" size="55" />
    <input type="submit" name="sa" value="Search" />
  </div>
</form>
<script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<table cellspacing=3 cellpadding=2 border=0>
<tr><td><tt>00:19.53</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad infobot (~infobot@rikers.org)</font></tt></td></tr>
<tr><td><tt>00:19.53</tt></td><td colspan=2><tt><font color="#009900">*** topic/#brlcad is GSoC students: if you have a question, ask and wait for an answer ... responses may take minutes or hours. Ask and WAIT. ;)</font></tt></td></tr>
<tr><td><tt>00:27.59</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad efjrugungwcmohmu (~armin@dslb-092-075-157-134.092.075.pools.vodafone-ip.de)</font></tt></td></tr>
<tr><td><tt>03:41.06</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad kintel (~kintel@unaffiliated/kintel)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>04:40.52</tt></td><td><font color="#ce6c6c"><tt>Notify</tt></font></td><td width="100%"><tt>03BRL-CAD Wiki:Ravilogaiya * 0 /wiki/User:Ravilogaiya: </tt></td></tr>
<tr><td><tt>05:31.46</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad kintel (~kintel@unaffiliated/kintel)</font></tt></td></tr>
<tr><td><tt>05:32.36</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad kintel (~kintel@unaffiliated/kintel)</font></tt></td></tr>
<tr><td><tt>05:33.21</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad kintel (~kintel@unaffiliated/kintel)</font></tt></td></tr>
<tr><td><tt>05:34.12</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad kintel (~kintel@unaffiliated/kintel)</font></tt></td></tr>
<tr><td><tt>05:35.02</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad kintel (~kintel@unaffiliated/kintel)</font></tt></td></tr>
<tr><td><tt>05:35.46</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad kintel (~kintel@unaffiliated/kintel)</font></tt></td></tr>
<tr><td><tt>06:04.33</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad KimK (~Kim__@2600:8803:7a81:7400:69b5:1646:8ec0:c796)</font></tt></td></tr>
<tr><td><tt>06:34.41</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad DaRock (~Thunderbi@mail.unitedinsong.com.au)</font></tt></td></tr>
<tr><td><tt>06:58.47</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad teepee (~teepee@unaffiliated/teepee)</font></tt></td></tr>
<tr><td><tt>07:36.20</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad Caterpillar (~caterpill@unaffiliated/caterpillar)</font></tt></td></tr>
<tr><td><tt>07:43.44</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad merzo (~merzo@93.94.41.67)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>07:49.32</tt></td><td><font color="#ce6c6c"><tt>Notify</tt></font></td><td width="100%"><tt>03BRL-CAD:Amritpal singh * 10057 /wiki/User:Amritpal_singh/GSoC17/logs: /* Coding Period */</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>07:53.11</tt></td><td><font color="#ce6c6c"><tt>Notify</tt></font></td><td width="100%"><tt>03BRL-CAD:Amritpal singh * 10058 /wiki/User:Amritpal_singh/GSoC17/logs: /* Coding Period */</tt></td></tr>
<tr><td><tt>08:12.20</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad teepee (~teepee@unaffiliated/teepee)</font></tt></td></tr>
<tr><td><tt>08:34.21</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad teepee (~teepee@unaffiliated/teepee)</font></tt></td></tr>
<tr><td><tt>08:51.53</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad teepee (~teepee@unaffiliated/teepee)</font></tt></td></tr>
<tr><td><tt>10:38.01</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad teepee (~teepee@unaffiliated/teepee)</font></tt></td></tr>
<tr><td><tt>11:43.38</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad teepee (~teepee@unaffiliated/teepee)</font></tt></td></tr>
<tr><td><tt>11:46.04</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad d_rossberg (~rossberg@104.225.5.10)</font></tt></td></tr>
<tr><td><tt>12:15.57</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad DaRock (~Thunderbi@mail.unitedinsong.com.au)</font></tt></td></tr>
<tr><td><tt>12:19.55</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad kintel (~kintel@unaffiliated/kintel)</font></tt></td></tr>
<tr><td><tt>12:58.55</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad kintel (~kintel@unaffiliated/kintel)</font></tt></td></tr>
<tr><td><tt>13:33.22</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad gabbar1947 (uid205515@gateway/web/irccloud.com/x-aihythsembbzujjz)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>13:48.51</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>gabbar1947: i run on a cmake error: inlude/rt/primitives/annot.h isn't there, and annot.h is twice inserted in the CMakeLists.txt</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>13:49.40</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>I'll check, give me a second</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>13:51.40</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>Rectified: I'm building on my system, just a moment</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:03.08</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>Uploaded, this should pass</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:07.08</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>gabbar1947: what is your intention behind your changes to the root CMakeLists.txt</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:07.14</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>?</tt></td></tr>
<tr><td><tt>14:08.31</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad yorik (~yorik@2804:431:f720:80d8:290:f5ff:fedc:3bb2)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:08.55</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>Actually I did not make any changes to the file, Its somehow reflected in the patch. </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:09.01</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>I'll check once</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:10.12</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>I'm unaware of any such change made by me, I have no idea why this reflects in the patch</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:12.21</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>i'm recommending looking at a patch file with a text editor and to check if it looks reasonable</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:13.18</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>I'll revert the change to the CmakeList.txt,&nbsp;&nbsp;Is there anything else that you want me to look into ?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:13.36</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>in addition you have trailing spaces in your code</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:14.13</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>the "good" text editors provide a function to remove them all in one step</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:14.58</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>I tried to remove as much as I could, anyways I'll go through the files once again. I'll use a text editor other than vim. </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:16.41</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>google says in vi it is :%s/\s\+$//e</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:18.22</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>see <a href="https://vi.stackexchange.com/questions/454/whats-the-simplest-way-to-strip-trailing-whitespace-from-all-lines-in-a-file/">https://vi.stackexchange.com/questions/454/whats-the-simplest-way-to-strip-trailing-whitespace-from-all-lines-in-a-file/</a></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:18.22</tt></td><td><font color="#6464be"><tt>gcibot</tt></font></td><td width="100%"><tt>[ What's the simplest way to strip trailing whitespace from all lines in a file? - Vi and Vim Stack Exchange ]</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:18.35</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>and its reference to vim.wikia</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:18.43</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>works! thank you</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:19.45</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>On it! just a moment&nbsp;&nbsp;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:22.20</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>i wrote my documents with vi for many years, you can write great literature with it - if you are tough enough for it</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:29.50</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>can you give it a try now, and let me know if there are more errors !</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:34.33</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>ok: typein.c has trailing spaces and a C++ comment (i.e. //)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:35.41</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>maybe you should simply remove the line - and the number of segments in p_annot for the sake of simplicity (see seans mail)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:35.52</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>I'll remove it ! The C++ instinct ! </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:38.01</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>Actually I wanted the "l" command to display the annotation container details as well, that was the reason for its inclusion. anyways i'm removing it!</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:38.13</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>run the :%s/\s\+$//e on all files you've touched to make sure that no trailing space left</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:38.38</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>isn't typein.c the in command?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:42.31</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>sorry, i had an old patch, in the actual one all trailing spaces seem to be gone</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:42.40</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>:)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:43.41</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>typein.c is the "in" command! but for the describe() function for annotation displays the container params as well, so just wanted to see the details on the screen, that's it !</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:44.22</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>ok, it's on your decision</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:46.58</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>I'm submitting the patch, once build completes !</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:55.45</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>UPLOADED</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:59.34</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>however, i've to go now :(</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:59.41</tt></td><td><font color="#6262bb"><tt>d_rossberg</tt></font></td><td width="100%"><tt>i'll see ...</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:11.36</tt></td><td><font color="#bcbc63"><tt>gabbar1947</tt></font></td><td width="100%"><tt>:)</tt></td></tr>
<tr><td><tt>15:38.26</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad merzo (~merzo@93.94.41.67)</font></tt></td></tr>
<tr><td><tt>15:49.55</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad vasc (~vasc@bl14-42-31.dsl.telepac.pt)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:50.01</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>hey</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:50.04</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>hello mdtwenty[m] </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:50.23</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>Hi :)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:51.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so... you said something about only supporting one partition?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:52.03</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>not only one partition.. one region</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:52.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>right.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:52.52</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but that isn't in the weaving part proper right?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:52.58</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's in the evaluation for rendering?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:53.37</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>yes it in the evaluation part</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:53.51</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well. you haven't implemented rt_boolfinal yet.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:54.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>is there anything left to do in the boolean weaving?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:55.36</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>i don't think so.. i think the boolean weaving is already fine</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:56.10</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>i was looking now into the rt_boolfinal</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:58.02</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>*i also uploaded today the weave patch without using the pointers in the cl_partition structure</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:58.38</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>yes. i've seen that. i'll have to review it more in depth later but it seems fine on a cursory glance.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:59.28</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>there's still the question of linked lists vs arrays, but without more complex test scenes there's no good way to benchmark it.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:02.15</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>the most complex test scenes on the standard database files are probably goliath and havoc. but i'm not sure if they use much csg</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:02.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>they probably don't.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:03.07</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>have you tried rendering those to see what happens?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:03.15</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and the operators scene.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:03.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>oh right. rendering issues.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:03.34</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:03.38</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>the havoc and the goliath?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:03.47</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>yes. havoc.g and goliath.g i think</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:03.53</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>in share/db or something.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:04.05</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>yes i see it</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:04.08</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>one sec</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:04.38</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>if it doesn't crash that would be good enough i guess.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:04.43</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>for now.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:05.27</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>hopefully it's not horrendously slow either.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:06.23</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>hm the goliath scene fails the assertion of 32 segments per ray</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:06.30</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>so i think 32 is not enough</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:06.30</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>hah.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:06.50</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>see what's the max depth.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:07.41</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's still prolly under 64,.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:08.24</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i think i have some dynamic bitvector code in opencl or ANSI C in here somewhere you could use if it's bigger than that.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:11.35</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>is there a function to see what is the max depth or something?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:12.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>no. just in that for loop where you do the assert, keep track of the max segments per ray size, and then print it out when the loop ends.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:13.18</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>there might be something like that in one of the brlcad tools, but i'm not sure if it would work with the opencl backend.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.00</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>ok found it</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.01</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>== host</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>cl_uint ND = N/WORD_BITS + 1;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>mD = clCreateBuffer(gpuCtx, CL_MEM_READ_WRITE, sizeof(cl_uint) * ND, NULL, NULL);</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>== device</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>inline uint bindex(const uint b) {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.03</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.05</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>}</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.07</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>inline uint bmask(const uint b) {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.11</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>}</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.13</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>inline uint isset(__global uint *bitset, const uint b) { </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.15</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.17</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>}</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.19</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>inline uint clr(__global uint *bitset, const uint b) { </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.21</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.23</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>}</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.25</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>inline uint set(__global uint *bitset, const uint b) { </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.27</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.29</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>}</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.31</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>-</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.33</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>this is my code, so i give you permission to it for any purpose.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:20.49</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>where WORD_BITS is 32 since 'D' is an array of cl_uints</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:21.33</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and N is the amount of bits you want the bitvector to have.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:21.42</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>i got maxdepth of 957571</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:21.48</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>WHAT</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:21.52</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>do the math properly dude.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:21.58</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>:-)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:22.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>that can't be truel.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:22.13</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>max per segment, not the sum of everything.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:22.55</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Still not a fan of allocating chunks out of big buffers through atomics, eh :)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:23.27</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>we might do that eventually. but for now there's a lot of gfx card memory we don't use.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:24.01</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>All right. It goes up quickly when buffering all hits for millions of rays</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:24.52</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well sure. we could find the warp size and only allocate a buffer of that size or something.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:24.57</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's too much work :-)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:25.27</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>those microoptimizations can be done later.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:25.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i kinda doubt we need to do it this way anyway.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:26.12</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i suspect we could do the csg processing in an iterative fashion with a modified algorithm.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:26.48</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>So you want to allocate the "max depth" for every ray... and how do you determine that max depth?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:27.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>we count the amount of segments per before allocating and actually storing the segments.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:27.33</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>we count the amount of segments per ray before allocating and actually storing the segments.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:27.37</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Ideally, you would process the segments as they come rather than buffering the whole thing. That complicates the code though</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:27.51</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Ah yes, the two passes thing, count then trace</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:28.04</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>yeah i suspect that could be done across the whole pipeline, but it requires rethinking the algorithm.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:28.14</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's probably non-trivial. but yeah it's worthwhile in the long run.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:28.48</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i'm just kinda reticent about doing it first hand without understanding how the current algorithm works properly.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:29.14</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>not just mechanically but in terms of performance as well.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:29.40</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>My raytracer used an inlined callback, the user could do whatever it wants with the hits. They can be processed on the fly (recommended) or buffered by a custom solution in the callback. And importantly, the inlined callback can terminate rays early</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:29.48</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>especially considering the guys who originally wrote the code didn't do it, and they worked on it for decades.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:30.10</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well, we kind of have something like that, </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:30.36</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>there's no storing of segments in the single pass version of the renderer.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:30.45</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Cool. Is the callback truly inlined? You want to avoid any function call on GPU, especially function pointers</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:30.45</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but that doesn't do CSG. </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:31.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and it only returns the first hit, or an accumulation of the result of all the hits.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:31.28</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>you can't have function pointers on opencl.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:31.40</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but yeah its some function.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:31.45</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Eheh. You can with CUDA, but it's a Very Bad Idea anyway</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:32.38</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>i was doing it wrongly :D</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:32.58</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>that version of the renderer is way faster than the current ANSI C one.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:33.04</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>i got 493 maxdepth for the goliath and 105 for the havoc</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:33.12</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but it doesn't do CSG so it isn't a proper comparison</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:33.16</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>really?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:33.21</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's still way more than i expected.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:33.32</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>vasc: I'm sure. My raytracer of triangles reached a billion rays per second... while a CPU core does 20M per second at most</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:33.44</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>(SSE optimized CPU code)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:33.56</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>mdtwenty[m], what's the amount of primitives in each scene?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:34.33</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>just for curiosity's sake.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:35.06</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i think there's a 'list' command in mged or something</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:35.25</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>goliath has 10499 primitives and havoc 2429</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:35.46</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>pfew, it's still smaller at least.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:35.58</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but...</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:36.09</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>There could be some ray hitting a bunch of aligned screws? :)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:36.10</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>well the good news is that the boolean weaving doenst crash</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:36.49</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well it might use an outrageous amount of memory.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:37.10</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so perhaps Stragus will get his thing.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:37.26</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>:-)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:37.48</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>the havoc with 105 is ok i guess.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:37.51</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but 493</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:38.10</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>that's 16 double words</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:38.25</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i.e. cl_uint [16]</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:38.41</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>yeah i got 493 while rendering with the front view</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:39.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>can you compute the amount of memory that would take with that size of bitvector?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:39.17</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>the whole segments array</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:39.39</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Why use the max depth for a ray though? Why not compute the sum of all rays, through a reduction kernel, if you are going to perform an identical trace right away?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:40.08</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>we have a bitvector we use inside each ray's segment list</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:40.15</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>(I still prefer dynamically allocated memory, but your way would work fine, except for the tracing-twice thing)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:41.00</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:41.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's like</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:41.06</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>we have a list of segments</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:41.11</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>which gets computed into a list of partitions</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:41.44</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and then that gets evaluated</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:42.05</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>So each ray computes how much storage it requires, it stores that number, and you reduce all these numbers to a grand total?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:42.13</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>each segment only belongs in one object right? but the partitions can belong to more than one.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:42.30</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>like the ray pierce one and exits the other. but it's the same partition solid space.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:42.52</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>yeah its kinda like that.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:43.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but that's only used to compute the amount of space we'll need.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:43.30</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>the actual algorithm isn't just a reduction.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:44.17</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Right... but what I'm saying is that it doesn't matter if the "max depth" is 40000 due to a bunch of aligned screws somewhere</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:44.25</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>You want the total for all rays</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:44.38</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>mdtwenty[m], another thing we could do is dynamically allocate the bitvector, so rays with more segments would get larger bitvectors, but i wonder if that would complicate the code too much.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:45.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>hmm</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:47.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so it's max_partitions*sizeof(cl_partition_without the bitvector)+max_partitions*sizeof(cl_uint)*(493/32)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:48.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>how much is that in bytes?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:48.17</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>mdtwenty[m]</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:48.44</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and this max_partitions is the total amount of partitions for all the rays.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:48.53</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>sum</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:49.48</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>one sec</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:03.16</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>hmm</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:03.31</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>perhaps this is not as a big of a deal as i thought</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+struct cl_partition {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_seg inseg;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_hit inhit;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_seg outseg;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_hit outhit;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.23</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;cl_uint segs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 32-bit vector to represent the segments in the partition */</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.25</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+};</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.30</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>struct cl_hit {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.37</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.39</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.41</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>};</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.43</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.46</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>struct cl_seg {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.47</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.49</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.51</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.53</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>};</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.55</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:04.57</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>who cares.</tt></td></tr>
<tr><td><tt>17:05.03</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad teepee (~teepee@unaffiliated/teepee)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:05.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's like just a cl_hit has 8+8+8+2+1 words</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:05.39</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>double words</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:05.57</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i.e. 27</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:06.25</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>That cl_hit struct is kind of heavy, like 84 bytes</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:06.29</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and each partition has like 6 of those</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:07.10</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so using even 16 double words for the bitvector seems pathetic in comparison.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:07.50</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>still i'm kinda interested to know how much memory the whole thing uses right now.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:08.29</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>Stragus, it's much, much worse than that.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:08.43</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>coz cl_double3's are ACTUALLY cl_double4s.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:09.15</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's an opencl thing.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:09.40</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and then there's struct alignment</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:09.49</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>which reminds me</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:09.58</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>mdtwenty[m], instead of this:</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+struct cl_partition {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_seg inseg;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_hit inhit;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_seg outseg;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_hit outhit;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.23</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;cl_uint segs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 32-bit vector to represent the segments in the partition */</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.24</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+};</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.27</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>try this:</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.38</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+struct cl_partition {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.38</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_seg inseg;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.38</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_seg outseg;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.38</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_hit inhit;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.38</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_hit outhit;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.39</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;cl_uint segs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 32-bit vector to represent the segments in the partition */</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.41</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+};</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:10.46</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and see if it's sizeof() is smaller.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:11.01</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>That shouldn't make a difference, both cl_hit and cl_seg have the same alignment</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:11.08</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i hope so.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:11.55</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>If these cl_double3 waste memory, then perhaps it should be packed differently</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:11.58</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>its the buildin cl_types that are an issue usually.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:12.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>builtin</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:12.45</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Although frankly, this whole data storage scheme is very unfriendly to GPUs and SIMD</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:12.55</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>hm</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:13.05</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>only because it isn't z-orderered.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:13.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>oh i see.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:13.34</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:13.39</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>No! Because you will have scattered loads/stores all over</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:13.48</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>All memory transactions will be 8 times slower than necessary</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:14.10</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>the thing is you probably don't need the whole thing across all stages of the algorithm</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:14.20</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so you could fraction this</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:14.33</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and increase memory locality.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:14.39</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>For best performance, all threads of a warp/wavefront need to access consecutive memory addresses</tt></td></tr>
<tr><td><tt>17:14.44</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad merzo (~merzo@194.140.108.146)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:15.01</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>So you need some struct where&nbsp;&nbsp;struct foo { float x[32]; float y[32]; etc. };</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:15.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>its like i said, you don't need to whole thing.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:15.07</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>even before that.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:15.45</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>yeah i know but if we minimize the size of the elements it ain't a big deal.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:15.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>the problem is the structs are too fat right now.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:16.20</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>still</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:16.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>in comparison to the ANSI C code, it's incredibly memory coherent ya know?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:16.40</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Not a big deal? The stride between elements doesn't matter unless it's in the same cache lines</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:17.00</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Well, these memory operations will be 8 times slower than if they were reorganized differently</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:17.14</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>That may or may not be a bottleneck, you'll decide that</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:17.31</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>even with a cache?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:17.34</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i'm not sure about that.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:17.53</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i think the main issue is to have poor memory locality in accesses.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:18.00</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>rather than the access patterns themselves.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:18.41</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>It's not about the cache, it's about memory transactions</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:18.52</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>memory bank conflicts?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:19.00</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>I am very sure about that, been doing CUDA for 8 years, and probably the biggest helper in #cuda...</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:19.16</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Bank conflicts are for shared memory</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:19.58</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well the thing is</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:20.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>if you're gonna need to access the rest of the struct in the same kernel</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:20.29</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's all going to have to be loaded anyway.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:20.30</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Presumably, all threads of the same warp/wavefront will also access the rest of their structs, no?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:21.15</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>that's the thing i said, i think we don't need to store everything in that struct in all the stages of the algorithm. it's just that currently we're slavishly following the way the existing ANSI C code is structured.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:21.37</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>like</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:21.54</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Okay! But it should still be designed so that consecutive threads access consecutive values in memory</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:22.02</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>You don't want a stride between threads</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:23.08</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i'll give you an example. i thought about doing that in the intersections code.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:23.29</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Consecutive addresses is _the_ solution that is fast on all GPUs from all vendors, for all generations. Beyond that, there are particularities if the accesses are shuffled, out of order, with gaps between chunks of 128 bytes, etc.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:23.33</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well it turns out each kernel still has so many branches. a lot of threads will be idling and it's awfully low performance.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:23.46</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>the GPU isn't maxed out.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:23.57</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>All right. But the threads that are active would still access a bunch of packed addresses</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:24.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>no it's actually terrible.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:24.33</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>imagine one thread is doing a quadric like a sphere, and the other is doing a thorus intersection.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:24.55</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Indeed, paths should be merged as much as possible. Coherent rays can help a lot with that</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:25.14</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well i thought about that. that actually kind of happens as it is.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:25.28</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>since i'm using a thread block.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:25.30</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:25.36</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>If there are some common operations between spheres and thorus, like storing data (memory transactions), they should be merged together</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:25.46</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i think the best thing would be to reorder the intersection calculations.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:25.47</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>As little code as possible should be specific to branches</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:25.57</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>That's possible, yes</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:26.21</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>like group the ones that use the same kernel solver together.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:27.18</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but the whole existing ANSI C code is more built to minimize the amount of operations than either memory consumption, or maximize memory coherency</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:27.18</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>It's possible to have warp-wide votes to decide how many threads need to perform operation X, before deciding to do it with a bunch of threads</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:27.38</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>or minimize branches</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:27.38</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>But these aren't as critical issues as properly organizing memory. Reshuffling memory implies rewriting a lot of code, so it must be done early</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:27.59</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Right, it's very different to optimize for scalar execution and for wide parallelism</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:28.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>its not just that</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:28.16</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's optimized for 1980s machines</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:28.20</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Oh I see, yes</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:28.32</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Memory was fast, ALUs were slow. And now it's the other way around</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:28.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>yep+</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:31.01</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so mdtwenty[m] any luck with that?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:33.19</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt><font color="#CC00CC">sent a long message: mdtwenty[m]_2017-06-23_17:33:18.txt &lt;<a href="https://matrix.org/_matrix/media/v1/download/matrix.org/hVZtHbkIpDKOvbklzQAQwlpz&gt;">https://matrix.org/_matrix/media/v1/download/matrix.org/hVZtHbkIpDKOvbklzQAQwlpz&gt;</a></font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:33.39</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>ok</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:33.47</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>what about the memory size of the whole thing?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:35.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; hmm</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:35.36</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; so it's max_partitions*sizeof(cl_partition_without the bitvector)+max_partitions*sizeof(cl_uint)*(493/32)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:35.36</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; how much is that in bytes?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:35.36</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; mdtwenty[m]</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:35.36</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; and this max_partitions is the total amount of partitions for all the rays.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:35.38</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; sum</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:35.41</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>i got 2337015024</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:35.55</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>for the goliath that has 493 depth</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:36.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>2 GB?!</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:37.04</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>ok, how much is&nbsp;&nbsp;max_partitions*sizeof(cl_partition_without the bitvector) alone?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:37.39</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>compiling</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:39.06</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>2 179 756 800</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:39.49</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>also i wanna see the code for bool_Eval</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:39.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so the bitvectors aren't the real problem</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.16</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>since they use a "mere" 200 MB or less.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.31</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>ok i think i got the idea</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.36</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+struct cl_partition {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.36</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_seg inseg;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.36</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_hit inhit;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.36</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_seg outseg;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.37</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;struct cl_hit outhit;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.37</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+&nbsp;&nbsp;&nbsp;&nbsp;cl_uint segs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 32-bit vector to represent the segments in the partition */</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.39</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+};</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.41</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>+</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:40.53</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>instead of storing copies of the cl_segs, why not use indexes instead?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:41.51</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>yes i think that it would work</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:43.40</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>((8*4*3+8+4)*2+4)*2 vs 4*2</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:43.45</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>440 vs 8</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:43.56</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>that should shrink things down</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:47.10</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so you have the code for bool_eval so i can look at it? i kind of want to understand which data in the partitions will get accessed in rt_boolfinal and rendering.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:49.30</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt><font color="#CC00CC">posted a file: ocl_bool_eval.patch (51KB) &lt;<a href="https://matrix.org/_matrix/media/v1/download/matrix.org/SFtMrGVveJAkLiBFABODKZMf&gt;">https://matrix.org/_matrix/media/v1/download/matrix.org/SFtMrGVveJAkLiBFABODKZMf&gt;</a></font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:49.40</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>this should be it</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:51.27</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>ok</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:51.40</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>i think that only the segments in the partition are relevant for boolean evaluation and shading</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:51.48</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>rt_boolfinal seems to hammer a partition's inhit/outhit .hit_hist's over and over.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:52.01</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>.hit_dist</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:52.11</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and then it computes segment regions</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:54.50</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>in a later optimization we may want to simplify the partition structures.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:55.03</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>struct cl_hit {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:55.03</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:55.03</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:55.03</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:55.03</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:55.04</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:55.06</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>};</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:55.15</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>of all of this, it looks as if rt_boolfinal only accesses the hit_dist.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:55.31</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i think the rest is only accessed in the final rendering stages.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:56.14</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but for now, just not storing the whole cl_segs in the cl_partitions should be enough.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:57.21</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Eh, still keep in mind that repacking of hits in structs of arrays of 32 or 64</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:58.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well the current code is horrible in several ways.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:58.25</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>just the amount of memory copies going on is kind of insane.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:58.34</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i'm surprised it's as fast as it is.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:58.44</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>How "fast" is fast? :)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:59.11</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>The reference CPU code is also abysmally slow, so it's not a great point of comparison</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:59.44</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>mdtwenty[m], after you use indexes instead of storing the whole cl_segs, test goliath and havok again. tell me the time it takes and if it crashes or not.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:00.00</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>Stragus, well it's what we have.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:00.26</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>mdtwenty[m], once you get that working, it's time to work on rt_boolfinal</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:00.54</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>mdtwenty[m], oh and tell me how much memory it uses to store the partitions now vs what it used before.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:01.05</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>with the indexes.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:01.10</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>and what about the bitvector for now?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:01.25</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>yes, use the dynamic bitvector too</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:01.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i paste the code above? did you get it?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:01.37</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>pasted</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:01.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; ok found it</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:01.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; == host</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:01.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; cl_uint ND = N/WORD_BITS + 1;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:01.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; mD = clCreateBuffer(gpuCtx, CL_MEM_READ_WRITE, sizeof(cl_uint) * ND, NULL, NULL);</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:01.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; == device</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.00</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; inline uint bindex(const uint b) {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt;&nbsp;&nbsp; return (b &gt;&gt; 5);</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.04</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; }</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.06</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; inline uint bmask(const uint b) {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.08</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt;&nbsp;&nbsp; return (1 &lt;&lt; (b &amp; 31));</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.10</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; }</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.12</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; inline uint isset(__global uint *bitset, const uint b) { </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.14</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt;&nbsp;&nbsp; return (bitset[bindex(b)] &amp; bmask(b));</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.16</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; }</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.18</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; inline uint clr(__global uint *bitset, const uint b) { </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.20</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt;&nbsp;&nbsp; return (bitset[bindex(b)] &amp;= ~bmask(b));</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.22</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; }</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.24</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; inline uint set(__global uint *bitset, const uint b) { </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.26</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt;&nbsp;&nbsp; return (bitset[bindex(b)] |= bmask(b));</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.28</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; }</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.30</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; -</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.32</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; this is my code, so i give you permission to it for any purpose.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.34</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; where WORD_BITS is 32 since 'D' is an array of cl_uints</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:02.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;vasc&gt; and N is the amount of bits you want the bitvector to have.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:03.10</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>basically you have a cl_uint array per bitvector</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:03.32</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>and you an use the isset, clr, or set functions to twiddle the bits.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:03.39</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>or query them.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:04.48</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>for a start you can just use a cl_uint segs[16]; or whatever</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:04.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but eventually you want to dynamically determine the size of this</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:05.39</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>the quick and dirty way to do it, is basically to pass it as a #define before the kernels are compiled.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:06.07</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>but don't do that.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:06.28</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>we'll probably need to optimize this some other way. but without more tests, it's hard to determine the appropriate solution,.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:07.05</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>That bitvector is to determine entry/exit status through solids?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:07.15</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>no</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:07.29</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it states which segments are within a partition</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:07.43</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>it's per ray </tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:08.01</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>we could do this some other way though</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:08.01</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Okay. I guess I'm not familiar enough with the terminology used by the BRL-CAD raytracer</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:08.27</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>if the bitvector is too sparse, we would probably be better off with using a list, like the current code already does.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:09.11</tt></td><td><font color="#d26ed2"><tt>Stragus</tt></font></td><td width="100%"><tt>Without knowing what the bitvector was, that was my thought</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:10.31</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>well.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:10.47</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i thought there would be less depth complexity in the average scene than ther actually is.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:10.50</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>my mistake.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:11.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>a typical game scene has like 3 depth complexity.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:12.05</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>in here we don't cull stuff.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:12.28</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i thought 32&nbsp;&nbsp;was enough. so much for that.</tt></td></tr>
<tr><td><tt>18:12.38</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad teepee (~teepee@unaffiliated/teepee)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:13.28</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i know there are hard limits in the amount of intersections per ray on triangle meshes in the current code for example.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:15.59</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt><a href="https://svn.code.sf.net/p/brlcad/code/brlcad/trunk/src/librt/primitives/bot/tie.c">https://svn.code.sf.net/p/brlcad/code/brlcad/trunk/src/librt/primitives/bot/tie.c</a></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:16.06</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:17.32</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>mdtwenty[m], if the bitvector is too slow on the goliath scene, we'll have to use lists again...</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:18.29</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>ok, i will change the bool weave to use the indexes for segments intead of the segs and will test</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:18.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>ok</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:22.20</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>hm</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.00</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so this is what the ANSI C code does for bool_eval of solids.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>case OP_SOLID:</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>register struct soltab *seek_stp = treep-&gt;tr_a.tu_stp;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>register struct seg **segpp;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.02</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>for (BU_PTBL_FOR(segpp, (struct seg **), &amp;partp-&gt;pt_seglist)) {</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.03</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.05</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>ret = 1;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.07</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>goto pop;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.09</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.11</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>}</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.13</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>ret = 0;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.15</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:23.17</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>&lt;PROTECTED&gt;</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:27.39</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>so</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:28.00</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>you need to know if a partition has a solid in it</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:31.31</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>a solid?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:33.43</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>a solid is basically a primitive object.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:33.54</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>like a sphere.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:34.03</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>in brlcad parlance.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:35.08</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>a solid object.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:39.01</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>i'll go jog for a while. should be back in 30-45 mins</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>18:39.56</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>Ok :) i will also take a break to get dinner</tt></td></tr>
<tr><td><tt>19:04.28</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad DaRock (~Thunderbi@mail.unitedinsong.com.au)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>20:17.32</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>20:38.16</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>so i changed the struct partition and it is working fine.. i am working on the dynamic bit vector right now</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>20:39.35</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>good. make sure to make a backup. :-)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>20:40.12</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>you'll have to initialize the data though</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>20:40.30</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>prolly the easiest way is to bzero the memory before using it.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>21:03.27</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>ok i will have to leave the house for a bit and probably will only get back to this tomorrow morning</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>21:05.17</tt></td><td><font color="#cccc6b"><tt>mdtwenty[m]</tt></font></td><td width="100%"><tt>i will notify you once its done</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>21:07.27</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>ok</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>21:08.42</tt></td><td><font color="#6bcb6b"><tt>vasc</tt></font></td><td width="100%"><tt>see you later then!</tt></td></tr>
</table>

<br>Generated by irclog2html.pl
Modified by <a href="http://Rikers.org">Tim Riker</a> to work with
<a href="http://infobot.sourceforge.net/">infobot</a>.
</body></html>
