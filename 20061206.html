<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>irclog2html for #brlcad on 20061206</title>
	<meta name="generator" content="irclog2html.pl by Jeff Waugh">
	<meta name="version" content="Version 1.5 - 11th May 2000">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body text="#000000" bgcolor="#ffffff">
<h1>irclog2html for #brlcad on 20061206</h1>
<table cellspacing=3 cellpadding=2 border=0>
<tr><td><tt>00:02.27</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad jpjacobs (n=jpjacobs@dib.ulyssis.student.kuleuven.be) [NETSPLIT VICTIM]</font></tt></td></tr>
<tr><td><tt>00:02.38</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad archivist (n=archivis@host217-35-76-52.in-addr.btopenworld.com) [NETSPLIT VICTIM]</font></tt></td></tr>
<tr><td><tt>00:04.24</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad dtidrow_work (n=dtidrow@host169.objectsciences.com) [NETSPLIT VICTIM]</font></tt></td></tr>
<tr><td><tt>00:04.26</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad _jack- (i=jack@dub.minimal.nl)</font></tt></td></tr>
<tr><td><tt>00:04.31</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad dtidrow (n=dtidrow@c-69-255-182-248.hsd1.va.comcast.net) [NETSPLIT VICTIM]</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>02:25.29</tt></td><td><font color="#5f5fb6"><tt>dtidrow</tt></font></td><td width="100%"><tt>brlcad: still on?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>04:25.54</tt></td><td><font color="#ce6c6c"><tt>ntroutman_</tt></font></td><td width="100%"><tt>any photon mapping people in here?</tt></td></tr>
<tr><td><tt>04:34.43</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad ntroutman (n=nathanie@prox.snu.edu)</font></tt></td></tr>
<tr><td><tt>08:15.25</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad clock_ (n=clock@zux221-122-143.adsl.green.ch)</font></tt></td></tr>
<tr><td><tt>10:21.53</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad docelic (i=docelic@ri02-043.dialin.iskon.hr)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:49.23</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Can anyone confirm my understanding of floating point math, specifically that if a &lt; b, then floor(a) will always be &lt;= floor(b) ?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:49.55</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Without possibility of bad rounding once in a billion</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:50.55</tt></td><td><font color="#d97272"><tt>clock_</tt></font></td><td width="100%"><tt>Maloeran: in floating point, no logic can be used.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:51.13</tt></td><td><font color="#d97272"><tt>clock_</tt></font></td><td width="100%"><tt>For example the following program printf("%f",a); printf("%f",a); printed two different numbers.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:51.27</tt></td><td><font color="#d97272"><tt>clock_</tt></font></td><td width="100%"><tt>And it was still in accordance to the behaviour of floating point numbers.</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:52.21</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>My present understanding of IEEE floats and floor() would imply that the logic above would always be true</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:54.24</tt></td><td><font color="#d97272"><tt>clock_</tt></font></td><td width="100%"><tt>yes, the floor() function is a nondecreasing one</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:55.33</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>I'm just unsure about broken implementations doing 32&lt;-&gt;80 bits conversions randomly, I know how the extra bits are discarded, truncation or rounding?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:55.40</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>I don't* know how</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:55.53</tt></td><td><font color="#d97272"><tt>clock_</tt></font></td><td width="100%"><tt>well there is no logic in floating point numbers</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:56.04</tt></td><td><font color="#d97272"><tt>clock_</tt></font></td><td width="100%"><tt>if you need to be able to predict the behaviour, use fixed point :D</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:56.38</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>There's logic for sure, it's still clearly predictable</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:57.15</tt></td><td><font color="#d9d972"><tt>archivist</tt></font></td><td width="100%"><tt>floats are not predictable never compare to 0 etc</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:57.40</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Yes, I know that</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:58.13</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>( And you can compare if you know for sure you are looking for an identical result )</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>14:59.02</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Basically, the point here is to do bin sorting, indexing floats in buckets.&nbsp;&nbsp;Can I be sure that all floats landing in bucket A will be &lt; than the ones in bucket A+1 ?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:00.33</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>That holds true as long as the implementation don't go around converting between multiple precisions ; I don't know if extra bits are truncated or rounded in that case</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:02.00</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>If that's a problem, I may as well extract mantissa and exponent manually, and work with that</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:07.35</tt></td><td><font color="#d97272"><tt>clock_</tt></font></td><td width="100%"><tt>Do you know how to get red_mask,... etc. from XWindowAttributes?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:08.15</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>ieee specifies several rounding models... down, up, truncation, nearest...</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:09.24</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>I THINK most x86 DEFAULTS to simple truncation, but it's not a defined thing... ummmmm, often there's an ieee header... like on fbsd, it's machine/ieeefp.h and I think on linux it's machine/ieee854.h</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:09.58</tt></td><td><font color="#d97272"><tt>clock_</tt></font></td><td width="100%"><tt>floor is always down</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:10.24</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>floor is always down, but in conversion (32/80 or 64/80), it's definable</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:10.39</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>by the standard... most chips don't implement ALL of the standard</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:12.12</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>(also, floor 3.000000000000000000000000000001 maybe interpreted as floor 2.99999999999999999999999999999 due to fp instabilities, and give 2.0ish)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:12.30</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>and visa versa</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:12.51</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>The way floor() should work, that should never happen</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:13.07</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>I'm concerned by any internal rounding though.. Ah, what a mess</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:13.09</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>fixed bit representation of floating point sucks arse</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:13.48</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>and dynamic width floating points (precise numbers) tend to incur a performance and memory penalty (scheme, ruby, libgmp, ...)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:14.35</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>The point at the moment is to sort points and planes faster than my initial quick and lazy balanced binary tree</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:14.51</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Bin sorting by floor() indexing would work, unless chips play dirty tricks on me</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:15.41</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>the dirty tricks will likely be in cases where #'s are so close, they don't really matter...</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:15.59</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>It matters a whole lot if 3.0000001 rounds to 2.0</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:16.26</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>it'd take more 0's than that</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:16.40</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Then the count of triangles in each bin is wrong, the traversal cost calculation is off, the actual sorting by comparison against the plane will give incorrect results, and it gets stuck in an infinite loop</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:17.02</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>I don't think you'd see it if you're happy with float precision</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:17.54</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>If I do such bin indexing, it is required for all points in bin A to be &lt; than the ones in bin A+1</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:18.01</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Unless things will go really bad :)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>15:18.06</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Otherwise* things</tt></td></tr>
<tr><td><tt>16:27.32</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad docelic (i=docelic@ri01-191.dialin.iskon.hr)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:39.21</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>Maloeran: for IEEE floating point, I believe that is a valid assertion &lt;=</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:41.26</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>but that isn't to say that there are plenty of libs and implementations that are not conformant out there (really a lot)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:43.15</tt></td><td><font color="#5f5fb6"><tt>dtidrow</tt></font></td><td width="100%"><tt>arg</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:43.17</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>at the hardware and library level really, to the point of not hoping for IEEE</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:43.51</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt><a href="http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/s_floorf.c?rev=1.7&amp;content-type=text/x-cvsweb-markup">http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/s_floorf.c?rev=1.7&amp;content-type=text/x-cvsweb-markup</a></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:43.52</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>gnarley</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:48.26</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Right, brlcad.. so I guess I can't rely on a comformant behavior on this point</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:49.17</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>depends what the purpose is really</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:49.18</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>i mean it should make things more stable overall</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:49.27</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>but it won't necessarily be rock solid</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:51.24</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>all you can guarantee rock solid is that you're within some epsilon, and doing greater/less than comparisons</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:51.46</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>*nod* fp sucks</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:52.00</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>With a big impact on performance</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:52.10</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>it's an approximate representation, so full on precision can't be guaranteed</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:52.44</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>pretty much a necessity for analytic purposes, but you could certain finagle some #cludgyness that would make it compile-time optional if you wanted</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:53.40</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>``Erik, I love floating point. I just wish implementations would all be perfectly predictable and conform to the standard</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:53.51</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>erm</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:53.53</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>the, uh</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:53.58</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>standard is not perfectly predictable</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:54.04</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>754 OR 854... :/</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:54.36</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>It is for the things I tend to care about, like this floor() thing</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:54.50</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>floor() is totally predictable</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:55.04</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>the number you THINK you have may not be the number you actually have</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:55.22</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Yes well, the internal conversions between different representations ( 80&lt;-&gt;32 ) mess things up a bit</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:55.26</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>if I have a very precise function and I feed it an imprecise input, I cannot expect the output to be any more precise than the input</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:55.43</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>I'm aware of that, I just need consistency</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:55.58</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>If a &lt; b, I need floor(a) to be &lt;= floor(b), always</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:56.04</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>it's not the function, it's the notion that you're using an approximate representation that induces the numeric instabilities</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:56.38</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>if floor() is floorf(), that's probabably a pretty safe assumption... it's probably safe on floord() as well</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:57.09</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>I would need to force the implementation to truncate back to 32 bits before floor(), if it's x87</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:58.48</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>floor() might not execute on the fpu</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:59.12</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>the url I pasted was how fbsd does it, it's a bit twiddle in integer there... I d'no leenewx or others</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:59.14</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>*shrug*</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:59.28</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>(and I don't know if that's a POSSIBLE path on fbsd, or an always path)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>16:59.55</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>There are faster hardware solutions, a couple cycles</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:00.27</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>it's highly unlikely you'll have problems, but there's that one little caveat that exists when you do anything at all involving floating point representation... :)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:01.51</tt></td><td><font color="#d97272"><tt>clock_</tt></font></td><td width="100%"><tt>Now if someone tells me how to run the damned mged in vnc server I can do screenshot videos in Theora, DivX and Windows Media Video</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:01.55</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Oh, I hit some very annoying fp problems with the old prototype before... :)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:02.38</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>I had a static function that would compute the bin index, and it was meant to always return the same index when given the same input. It makes sense of course, I had to debug for a long while to discover that... it didn't!</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:02.53</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>clock: um, /usr/brlcad/bin/mged ?</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:02.56</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>The reason : GCC was inlining it, and it messed up the 80&lt;-&gt;32 bits x87 conversions</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:03.24</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>heh</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:06.49</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>1) Correct&nbsp;&nbsp;&nbsp;&nbsp;21081851083600.37596259382529338 0x42b32c803ebb5060</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:06.49</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>2) SPARC-quad 21081851083600.37500000000000&nbsp;&nbsp;&nbsp;&nbsp;0x42b32c803ebb5060</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:06.49</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>4) IA32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21081851083600.38281250000000&nbsp;&nbsp;&nbsp;&nbsp;0x42b32c803ebb5062</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:06.53</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>interesting</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:07.23</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>Maloeran: subtracting the two and comparing against an epsilon should be way faster than calling floor() twice (or even once)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:08.05</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt><a href="http://www.validlab.com/goldberg/paper.pdf">http://www.validlab.com/goldberg/paper.pdf</a></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:08.12</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>brlcad, it was for sorting in bins... Make yourself 256 bins, find in which bin a point lands by a mere floor()</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:08.13</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt><a href="http://72.5.124.65/sunstudio/articles/fp_errors.html">http://72.5.124.65/sunstudio/articles/fp_errors.html</a></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:09.22</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>"by a mere floor()" sounds rather misleading</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:09.47</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>I'd then say that "by a mere macro" you could do that same thing much faster</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:11.00</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Hum, a macro? I mean it's a serial operation without branching, you get the bin index directly after an add and a mul</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:11.25</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>floor() has several branch points in the msun package</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:11.37</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>floor() has no branches when executed by the hardware ;)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:11.51</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>These are probably fallbacks</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:12.00</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>hrm</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:12.14</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>I'd expect certain flags to be set depending on what exactly happened</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:12.26</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>:/</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:13.09</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>-ffast-math purposefully breaks ieee for speed</tt></td></tr>
<tr><td><tt>17:14.07</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad docelic (i=docelic@ri01-094.dialin.iskon.hr)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:14.31</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Even that software implementation is better than the 8 nodes of a binary tree to sort in 256 buckets for example</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:14.45</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>*shrug*</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:14.47</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>so do it</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:14.51</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>and see if the test cases get faster</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:14.53</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>:)</tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:21.21</tt></td><td><font color="#dada73"><tt>``Erik</tt></font></td><td width="100%"><tt>heh <a href="http://support.microsoft.com/kb/214118">http://support.microsoft.com/kb/214118</a></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>17:24.22</tt></td><td><font color="#d97272"><tt>clock_</tt></font></td><td width="100%"><tt>Use Precision as Displayed option in Word ;-)</tt></td></tr>
<tr><td><tt>18:48.24</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad docelic (i=docelic@ri01-229.dialin.iskon.hr)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>20:33.25</tt></td><td><font color="#72d8d8"><tt>Maloeran</tt></font></td><td width="100%"><tt>Tip of the day : Blizzards and bicycles are a poor combination</tt></td></tr>
<tr><td><tt>20:42.36</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad b0ef (n=b0ef@084202024060.customer.alfanett.no)</font></tt></td></tr>
<tr><td><tt>20:58.06</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad docelic (i=docelic@ri01-207.dialin.iskon.hr)</font></tt></td></tr>
<tr><td><tt>21:20.51</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad clock_ (i=clock@84-72-63-202.dclient.hispeed.ch)</font></tt></td></tr>
<tr bgcolor="#eeeeee"><td><tt>21:35.07</tt></td><td><font color="#ae5b5b"><tt>brlcad</tt></font></td><td width="100%"><tt>heh, "tip" of the day, nice pun</tt></td></tr>
<tr><td><tt>22:31.53</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad docelic (i=docelic@ri01-220.dialin.iskon.hr)</font></tt></td></tr>
<tr><td><tt>23:29.33</tt></td><td colspan=2><tt><font color="#009900">*** join/#brlcad b0ef (n=b0ef@084202024060.customer.alfanett.no)</font></tt></td></tr>
</table>

<br>Generated by irclog2html.pl by
<a href="mailto:jdub@NOSPAMaphid.net">Jeff Waugh</a> - find it at
<a href="http://freshmeat.net/appindex/2000/03/28/954251322.html">freshmeat.net</a>!
Modified by <a href="http://www.Rikers.org">Tim Riker</a> to work with
<a href="http://blootbot.sourceforge.net/">blootbot</a> logs, split per channel, etc.
</body></html>
