<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.6.0" />
<title>IRC log for #brlcad on 20150815</title>
<meta name="generator" content="irclog2html.pl" />
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<style type="text/css">
/*<![CDATA[*/
 body {
  background-color: #FFFFFF;
  color: #000000;
 }
 span.c12 {color: #000099}
 span.c11 {color: #DE7575}
 span.c10 {color: #D97272}
 span.c9 {color: #60B6B6}
 span.c8 {color: #009900}
 span.c7 {color: #CC00CC}
 span.c6 {color: #62BB62}
 span.c5 {color: #5FB4B4}
 span.c4 {color: #57A657}
 tr.c3 {background-color: #EEEEEE}
 span.c2 {color: #97974F}
 ins.c1 {display:inline-block;width:728px;height:90px}
/*]]>*/
</style>
</head>
<body>
<h1>IRC log for #brlcad on 20150815</h1>
<script async="async" src=
"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Default -->
<ins class="adsbygoogle c1" data-ad-client=
"ca-pub-1563266826402652" data-ad-slot="5026919875"></ins> 
<script>
<![CDATA[

(adsbygoogle = window.adsbygoogle || []).push({});
]]>
</script>
<form action="http://www.google.com" id="cse-search-box">
<div><input type="hidden" name="cx" value=
"partner-pub-1563266826402652:3301963896" /> <input type="hidden"
name="ie" value="UTF-8" /> <input type="text" name="q" size="55" />
<input type="submit" name="sa" value="Search" /></div>
</form>
<script type="text/javascript" src=
"http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<table cellspacing="3" cellpadding="2" border="0">
<tr class="c3">
<td><tt>00:04.21</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Vasco, so you imported some BVH code from
somewhere? Eh, that works</tt></td>
</tr>
<tr class="c3">
<td><tt>00:07.27</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65926
(brlcad/branches/opencl/include/rt/shoot.h
brlcad/branches/opencl/src/librt/primitives/primitive_util.c
brlcad/branches/opencl/src/rt/do.c): allow opencl lightmodel
argument passing from the command line.</tt></td>
</tr>
<tr class="c3">
<td><tt>00:12.11</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i think its MIT Licensed</tt></td>
</tr>
<tr class="c3">
<td><tt>00:12.53</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>only way to do in the schedule</tt></td>
</tr>
<tr class="c3">
<td><tt>00:13.13</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>there's a CUDA version of the code as well.
dunno about any OpenCL version though.</tt></td>
</tr>
<tr class="c3">
<td><tt>00:13.57</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>there's a reason why i proposed the
grid</tt></td>
</tr>
<tr class="c3">
<td><tt>00:14.15</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>decent quality bvh builders are quite hairy to
implement</tt></td>
</tr>
<tr class="c3">
<td><tt>00:14.25</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Yes, it's quite a bit of code</tt></td>
</tr>
<tr class="c3">
<td><tt>00:14.47</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>But that's a good solution. It's worth
implementing things well or not at all, so that someone else will
do it</tt></td>
</tr>
<tr class="c3">
<td><tt>00:15.10</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>well it can now render some scenes like 45x
faster</tt></td>
</tr>
<tr class="c3">
<td><tt>00:15.34</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>brute force is gone</tt></td>
</tr>
<tr class="c3">
<td><tt>00:16.03</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i think its like 4-5x faster than the cpu
version right now</tt></td>
</tr>
<tr class="c3">
<td><tt>00:16.16</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Cool</tt></td>
</tr>
<tr class="c3">
<td><tt>00:16.28</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>well it doesn't do csg or a bunch of other
things</tt></td>
</tr>
<tr class="c3">
<td><tt>00:16.54</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>I thought it was only the BVH builder, working
on abstract "objects"</tt></td>
</tr>
<tr class="c3">
<td><tt>00:17.15</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Where said objects can be CSG objects of
specified weight/cost</tt></td>
</tr>
<tr class="c3">
<td><tt>00:18.00</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD Wiki:Bhollister * 9353
/wiki/User:Bhollister/DevLogAug2015: /* Fri, August 14, 2015
*/</tt></td>
</tr>
<tr class="c3">
<td><tt>00:18.06</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i'm only computing all intersections on the
ray path and discarding those results that are behind something
else</tt></td>
</tr>
<tr class="c3">
<td><tt>00:18.26</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>so i guess it only supports the union
operator</tt></td>
</tr>
<tr class="c3">
<td><tt>00:18.30</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>ar ar</tt></td>
</tr>
<tr class="c3">
<td><tt>00:18.40</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>:) It's a good starting point</tt></td>
</tr>
<tr class="c3">
<td><tt>00:19.23</tt></td>
<td><span class="c6"><tt>bhollister3</tt></span></td>
<td width="100%"><tt>starseeker: patch #405 has been newly
submitted.</tt></td>
</tr>
<tr class="c3">
<td><tt>00:19.46</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>btw i added that callback to process hits like
you mentioned</tt></td>
</tr>
<tr class="c3">
<td><tt>00:20.19</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Cool, that will make it easier to extend
functionalities</tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.02</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>none of this is on trunk though.  the memory
allocations of the bvh builders are still a bit of a mess</tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.36</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Is the BVH built as one chunk of memory or
it's a mess of pointers?</tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.47</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>its a linearized tree</tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.49</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>one chunk</tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.52</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>That's good</tt></td>
</tr>
<tr class="c3">
<td><tt>00:22.55</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD Wiki:Bhollister * 9354
/wiki/User:Bhollister/DevLogAug2015: /* Fri, August 14, 2015
*/</tt></td>
</tr>
<tr class="c3">
<td><tt>00:22.59</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>e.g. for the goliath it takes 0.08MB of
RAM</tt></td>
</tr>
<tr class="c3">
<td><tt>00:23.30</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>but i'm using 255 primitives per leaf i think
feh</tt></td>
</tr>
<tr class="c3">
<td><tt>00:23.47</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>These are some heavy leaves</tt></td>
</tr>
<tr class="c3">
<td><tt>00:23.48</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i'll need to figure out a proper setting
eventually</tt></td>
</tr>
<tr class="c3">
<td><tt>00:24.14</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Consdering the high cost of intersection,
leaves should be as small as possible</tt></td>
</tr>
<tr class="c3">
<td><tt>00:24.36</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>well on bvhs the leaves should be a bit bigger
than on kd-trees</tt></td>
</tr>
<tr class="c3">
<td><tt>00:24.39</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD Wiki:Bhollister * 9355
/wiki/MGED_CMD_nmg:</tt></td>
</tr>
<tr class="c3">
<td><tt>00:24.45</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>coz the bounding boxes take up a lot of
space</tt></td>
</tr>
<tr class="c3">
<td><tt>00:25.11</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>but yeah the ideal trees are usually 'stringy'
with few primitives per leaf</tt></td>
</tr>
<tr class="c3">
<td><tt>00:25.17</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Right</tt></td>
</tr>
<tr class="c3">
<td><tt>00:25.38</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i'll eventually do some benchmarking to figure
out a value</tt></td>
</tr>
<tr class="c3">
<td><tt>00:26.33</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>even with these big leaves it takes like half
a second to render the goliath</tt></td>
</tr>
<tr class="c3">
<td><tt>00:27.03</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>First hit only?</tt></td>
</tr>
<tr class="c3">
<td><tt>00:27.13</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>yeah</tt></td>
</tr>
<tr class="c3">
<td><tt>00:27.35</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i think it takes like 1.5s to render it with
BRL-CAD proper</tt></td>
</tr>
<tr class="c3">
<td><tt>00:27.39</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Darn</tt></td>
</tr>
<tr class="c3">
<td><tt>00:27.48</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>well the boxes a kinda big</tt></td>
</tr>
<tr class="c3">
<td><tt>00:27.51</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>are</tt></td>
</tr>
<tr class="c3">
<td><tt>00:28.07</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it's just changing some constant
somewhere</tt></td>
</tr>
<tr class="c3">
<td><tt>00:28.33</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Normally, it should be changing the traversal
cost weights of the objects...</tt></td>
</tr>
<tr class="c3">
<td><tt>00:28.36</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i usually see 8x speedup when i port things to
gpu</tt></td>
</tr>
<tr class="c3">
<td><tt>00:28.42</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>but this one is more like 4-5x</tt></td>
</tr>
<tr class="c3">
<td><tt>00:28.52</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>The BRL-CAD raytracer doesn't use
SSE/AVX</tt></td>
</tr>
<tr class="c3">
<td><tt>00:28.56</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>coz of the doubles</tt></td>
</tr>
<tr class="c3">
<td><tt>00:29.01</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Oh right, doubles</tt></td>
</tr>
<tr class="c3">
<td><tt>00:29.45</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>The float speed-up would normally be about
60x, but with these doubles, it might go from 2x to 20x</tt></td>
</tr>
<tr class="c3">
<td><tt>00:29.57</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>nah it ain't that good</tt></td>
</tr>
<tr class="c3">
<td><tt>00:30.19</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>not against MT and SIMD CPU code</tt></td>
</tr>
<tr class="c3">
<td><tt>00:30.36</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>but OpenCL can run on the CPU as
well</tt></td>
</tr>
<tr class="c3">
<td><tt>00:30.47</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>BRL-CAD's raytracer doesn't use any
SSE/AVX</tt></td>
</tr>
<tr class="c3">
<td><tt>00:30.54</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it does now :-)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:31.01</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Through OpenCL?</tt></td>
</tr>
<tr class="c3">
<td><tt>00:31.03</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>yeah</tt></td>
</tr>
<tr class="c3">
<td><tt>00:31.09</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Does that work well?</tt></td>
</tr>
<tr class="c3">
<td><tt>00:31.38</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i have to change the code and recompile to
check. there's no command line option to select device yet. it just
picks the first on the list</tt></td>
</tr>
<tr class="c3">
<td><tt>00:32.31</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>no i didn't code that</tt></td>
</tr>
<tr class="c3">
<td><tt>00:33.14</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i have an AMD FX 8350</tt></td>
</tr>
<tr class="c3">
<td><tt>00:34.42</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>0.18 sec for that scene that takes 0.09 sec on
the GPU</tt></td>
</tr>
<tr class="c3">
<td><tt>00:34.53</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>its only 2x faster on the GPU</tt></td>
</tr>
<tr class="c3">
<td><tt>00:35.15</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>There's plenty of optimization work left, but
you apparently did a big chunk</tt></td>
</tr>
<tr class="c3">
<td><tt>00:35.32</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>the memory writes need to be optimized a
lot</tt></td>
</tr>
<tr class="c3">
<td><tt>00:35.33</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>I have a lot of CUDA experience but I have
never used doubles, I'm not sure what to expect</tt></td>
</tr>
<tr class="c3">
<td><tt>00:36.11</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Highly parallel code can be 20x faster on a
single GPU than multi-threaded SSE/AVX optimized numa-aware CPU
code</tt></td>
</tr>
<tr class="c3">
<td><tt>00:36.18</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>... with floats</tt></td>
</tr>
<tr class="c3">
<td><tt>00:36.23</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>right</tt></td>
</tr>
<tr class="c3">
<td><tt>00:36.45</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>but i usually see more like 8x</tt></td>
</tr>
<tr class="c3">
<td><tt>00:37.11</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>its the damned thread divergence</tt></td>
</tr>
<tr class="c3">
<td><tt>00:38.16</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>that's the thing with OpenCL. it can target a
lot of architectures</tt></td>
</tr>
<tr class="c3">
<td><tt>00:38.21</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>even if the tools kinda suck</tt></td>
</tr>
<tr class="c3">
<td><tt>00:38.40</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>the language itself is perfectly
fine</tt></td>
</tr>
<tr class="c3">
<td><tt>00:38.52</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>with some exceptions</tt></td>
</tr>
<tr class="c3">
<td><tt>00:38.54</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>OpenCL code always needs to target a specific
architecture if you want good performance</tt></td>
</tr>
<tr class="c3">
<td><tt>00:39.00</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>well yeah but</tt></td>
</tr>
<tr class="c3">
<td><tt>00:39.06</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>you can say the same for C code</tt></td>
</tr>
<tr class="c3">
<td><tt>00:39.16</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Even with CUDA, I have plenty of #if depending
if I'm running on Fermi, Kepler or Maxwell</tt></td>
</tr>
<tr class="c3">
<td><tt>00:39.42</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Well... yes, except most C code runs on x86
chips with few differences</tt></td>
</tr>
<tr class="c3">
<td><tt>00:39.49</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>today maybe</tt></td>
</tr>
<tr class="c3">
<td><tt>00:39.57</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>all the world is either x86 or ARM</tt></td>
</tr>
<tr class="c3">
<td><tt>00:40.26</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>x86 on laptops and above and ARM on tablets
and below</tt></td>
</tr>
<tr class="c3">
<td><tt>00:40.32</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Right</tt></td>
</tr>
<tr class="c3">
<td><tt>00:40.43</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Optimization guidelines on ARM are fairly
close to x86</tt></td>
</tr>
<tr class="c3">
<td><tt>00:41.12</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>the only quirky thing it had that i remember
was that branch target bit or whatever</tt></td>
</tr>
<tr class="c3">
<td><tt>00:42.08</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i never did assembly on ARM</tt></td>
</tr>
<tr class="c3">
<td><tt>00:42.17</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>only x86</tt></td>
</tr>
<tr class="c3">
<td><tt>00:42.26</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>and MIPS i guess but that was on
paper</tt></td>
</tr>
<tr class="c3">
<td><tt>00:42.28</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>:-)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:43.09</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>MIPS, that still exists? :)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:43.33</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>I read a lot on ARM and NEON, just to reassure
myself that not all architectures have to be as poorly designed as
x86</tt></td>
</tr>
<tr class="c3">
<td><tt>00:43.41</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>well the hennessy and patterson books uses
MIPS and DLX</tt></td>
</tr>
<tr class="c3">
<td><tt>00:43.53</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>yeah x86 is pretty bad</tt></td>
</tr>
<tr class="c3">
<td><tt>00:43.59</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Although I found the ISA of all CUDA hardware
fantastic</tt></td>
</tr>
<tr class="c3">
<td><tt>00:44.05</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>yes me too</tt></td>
</tr>
<tr class="c3">
<td><tt>00:44.13</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>lots of nice instructions and its quite
orthogonal</tt></td>
</tr>
<tr class="c3">
<td><tt>00:44.52</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>the x86 did get a lot better with i386 and
x86-64 though</tt></td>
</tr>
<tr class="c3">
<td><tt>00:45.12</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>The weight of legacy is terrible</tt></td>
</tr>
<tr class="c3">
<td><tt>00:45.31</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>AMD at one point wanted to replace x87 but
eventually they gave up</tt></td>
</tr>
<tr class="c3">
<td><tt>00:45.41</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i think they called it the Technical Floating
Point instructions</tt></td>
</tr>
<tr class="c3">
<td><tt>00:45.43</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>three operand FP</tt></td>
</tr>
<tr class="c3">
<td><tt>00:45.49</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>no stack shit</tt></td>
</tr>
<tr class="c3">
<td><tt>00:45.56</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>The "Clear the interrupt flag" instruction is
just one byte, but the "dot product" SSE 4.1 instruction is 5 (!!)
bytes, plus 2 bytes for operands and two prefixes, so 9
bytes</tt></td>
</tr>
<tr class="c3">
<td><tt>00:46.16</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it's got seniority</tt></td>
</tr>
<tr class="c3">
<td><tt>00:46.51</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>all the flags instructions on x86 are probably
going to bite them in the ass in the future</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.19</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it makes wide processors a problem</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.21</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Yes... and implicit operands not allowing good
parallelism, all instructions modifying flags, etc.</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.53</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>The worst problem is probably the guaranteed
L1 cache synchronization between cores, it makes scalability very
troublesome for the hardware</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.56</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>does PTX even have flags? i don't think
so</tt></td>
</tr>
<tr class="c3">
<td><tt>00:48.21</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>CUDA hardware could have a million cores, but
x86? Ah... we have serious headaches going above 16</tt></td>
</tr>
<tr class="c3">
<td><tt>00:48.35</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>well the Xeon Phi has quite a lot of
them</tt></td>
</tr>
<tr class="c3">
<td><tt>00:48.44</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>All cores need to talk to each other to
synchronize their L1 cache due to memory coherency guarantees of
the architecture</tt></td>
</tr>
<tr class="c3">
<td><tt>00:49.10</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>yeah that particular choice of memory protocol
wasn't probably the best either</tt></td>
</tr>
<tr class="c3">
<td><tt>00:49.50</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>Xeon Phi 61 cores</tt></td>
</tr>
<tr class="c3">
<td><tt>00:50.31</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>I wonder if they relaxed the memory coherency
guarantees, requiring actual memory fences</tt></td>
</tr>
<tr class="c3">
<td><tt>00:52.37</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Apparently not, it features the same x86 cache
coherence guarantees</tt></td>
</tr>
<tr class="c3">
<td><tt>00:52.43</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i think they had this ring bus</tt></td>
</tr>
<tr class="c3">
<td><tt>00:52.48</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>in the early ones</tt></td>
</tr>
<tr class="c3">
<td><tt>00:52.52</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>connecting the processors</tt></td>
</tr>
<tr class="c3">
<td><tt>00:52.57</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i mean the cores</tt></td>
</tr>
<tr class="c3">
<td><tt>00:52.58</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Right</tt></td>
</tr>
<tr class="c3">
<td><tt>00:54.08</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it's probably the next iteration of the Intel
fail architecture for the technical computing market</tt></td>
</tr>
<tr class="c3">
<td><tt>00:54.26</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>which will join the i860, Itanium</tt></td>
</tr>
<tr class="c3">
<td><tt>00:54.30</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Yup</tt></td>
</tr>
<tr class="c3">
<td><tt>00:54.48</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it's too big and hot</tt></td>
</tr>
<tr class="c3">
<td><tt>00:55.00</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>something that can only sell for the server
market ain't gonna do it</tt></td>
</tr>
<tr class="c3">
<td><tt>00:55.28</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>It's not even good. A consumer-grade GPU beats
a $2k Xeon Phi</tt></td>
</tr>
<tr class="c3">
<td><tt>00:55.33</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>if anything the gpus might eventually enter
their space.</tt></td>
</tr>
<tr class="c3">
<td><tt>00:56.11</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>what's that nvidia thingie called.... i think
its Denver</tt></td>
</tr>
<tr class="c3">
<td><tt>00:56.51</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>ah no they changed the name</tt></td>
</tr>
<tr class="c3">
<td><tt>00:57.04</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>or not</tt></td>
</tr>
<tr class="c3">
<td><tt>00:57.34</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>The ARM CPU in Nexus 9?</tt></td>
</tr>
<tr class="c3">
<td><tt>00:58.09</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>yeah</tt></td>
</tr>
<tr class="c3">
<td><tt>00:58.17</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it's ARM compatible but its not an ARM chip
design</tt></td>
</tr>
<tr class="c3">
<td><tt>00:58.51</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>its their answer to the Itanium i guess.
snark.</tt></td>
</tr>
<tr class="c3">
<td><tt>00:59.08</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>its some kind of VLIW with code morphing. now
that would be transmeta i guess.</tt></td>
</tr>
<tr class="c3">
<td><tt>00:59.41</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it's weird that one</tt></td>
</tr>
<tr class="c3">
<td><tt>00:59.54</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Yes, I never really read anything about
it</tt></td>
</tr>
<tr class="c3">
<td><tt>01:00.03</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>allegedly NVIDIA wanted to do x86 compat. not
ARM compat for the Denver.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:00.14</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>then they switched to supposedly being able to
target both</tt></td>
</tr>
<tr class="c3">
<td><tt>01:00.29</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>then i think they hit a slight snag with Intel
patent licensing</tt></td>
</tr>
<tr class="c3">
<td><tt>01:00.50</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>I want a CPU where I can reprogram the
instruction decoder</tt></td>
</tr>
<tr class="c3">
<td><tt>01:00.57</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>or at least that's how the rumour mill
went</tt></td>
</tr>
<tr class="c3">
<td><tt>01:01.26</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>Denver is 7-wide</tt></td>
</tr>
<tr class="c3">
<td><tt>01:01.38</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Look ago, I looked into writing AMD micro-code
to reprogram the instruction decoding</tt></td>
</tr>
<tr class="c3">
<td><tt>01:01.55</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Not surprisingly, information was *very*
scarse</tt></td>
</tr>
<tr class="c3">
<td><tt>01:02.07</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>yeah. imagine removing a virus in
that.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:02.13</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Long* ago</tt></td>
</tr>
<tr class="c3">
<td><tt>01:02.25</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Eh, yes</tt></td>
</tr>
<tr class="c3">
<td><tt>01:02.25</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i think the PAL on the Alpha was
programmable.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:02.34</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>they used it for VAX emulation and stuff like
that.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:02.39</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>All modern x86 CPUs have programmable
microcodes</tt></td>
</tr>
<tr class="c3">
<td><tt>01:02.52</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Except that Intel and AMD are keeping their
mouth completely shut on the topic</tt></td>
</tr>
<tr class="c3">
<td><tt>01:03.15</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>well people might find out how many bugs their
processors really have it they didn't</tt></td>
</tr>
<tr class="c3">
<td><tt>01:03.34</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i think i read that Intel disabled TSX
recently</tt></td>
</tr>
<tr class="c3">
<td><tt>01:03.36</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>I had figured out that all AMD "direct path"
instructions were not programmable, but the "vector path"
instructions were interpreted by the microcode</tt></td>
</tr>
<tr class="c3">
<td><tt>01:03.57</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>well</tt></td>
</tr>
<tr class="c3">
<td><tt>01:04.05</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it takes a long time to design a
processor</tt></td>
</tr>
<tr class="c3">
<td><tt>01:04.20</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>and Intel keeps changing the instruction set
and not telling anyone about it until its too late</tt></td>
</tr>
<tr class="c3">
<td><tt>01:04.25</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>so microcode to the rescue.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:04.33</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Eheh</tt></td>
</tr>
<tr class="c3">
<td><tt>01:05.12</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt><span class="c7">wants to reprogram the opcode
map so that all common SSE/AVX instructions get a single byte
opcode</span></tt></td>
</tr>
<tr class="c3">
<td><tt>01:05.32</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>to improve code density? that's
interesting.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:05.51</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>but the short ones are prolly
reserved.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:05.53</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Many modern processors actually choke on the
instruction decoding</tt></td>
</tr>
<tr class="c3">
<td><tt>01:06.08</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Instruction decoding is a bottleneck in many
cases, due to the SSE/AVX instruction taking so many bytes and
prefixes</tt></td>
</tr>
<tr class="c3">
<td><tt>01:06.27</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>yeah x86 has so many additions and changes its
like a kiltwork ISA</tt></td>
</tr>
<tr class="c3">
<td><tt>01:06.46</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>quilt work</tt></td>
</tr>
<tr class="c3">
<td><tt>01:06.58</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>We have 1 byte opcodes to do things like "add
1 to eax" and so on</tt></td>
</tr>
<tr class="c3">
<td><tt>01:07.14</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>that one actually makes sense</tt></td>
</tr>
<tr class="c3">
<td><tt>01:07.40</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>there's also the fabled XOR EAX, EAX coz its
smaller than MOV EAX, 0</tt></td>
</tr>
<tr class="c3">
<td><tt>01:08.16</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Okay... what about the single byte "aad"
instruction, ASCII adjust AX before division by 10? :)</tt></td>
</tr>
<tr class="c3">
<td><tt>01:08.38</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it probably made sense when they wanted to
sell POS. you know cash registers.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:08.53</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>that and the BCD mode crap.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:09.18</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Yes, it's part of the many BCD instructions,
opcodes all taking a single byte</tt></td>
</tr>
<tr class="c3">
<td><tt>01:09.49</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Or other one-byte instructions like "bounds",
check if a number is between two numbers or not</tt></td>
</tr>
<tr class="c3">
<td><tt>01:09.56</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i think we used that in the lab when i was an
undergrad to program this segmented LED display</tt></td>
</tr>
<tr class="c3">
<td><tt>01:10.40</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i think the string instructions are even more
useless</tt></td>
</tr>
<tr class="c3">
<td><tt>01:10.59</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Oh, did you know that the "inc" (increment)
and "dec" (decrement) instructions have a single-byte opcode for
every single register?</tt></td>
</tr>
<tr>
<td><tt>01:11.27</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad vasc__
(~vasc@bl13-126-172.dsl.telepac.pt)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>01:12.00</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Oh, did you know that the "inc" (increment)
and "dec" (decrement) instructions have a single-byte opcode for
every single register?</tt></td>
</tr>
<tr class="c3">
<td><tt>01:12.03</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Opcode 40h: inc ax, opcode 41h: inc cx, opcode
42h: inc dx, opcode 43h: inc sp</tt></td>
</tr>
<tr class="c3">
<td><tt>01:12.13</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>We have *that* and we have 9 bytes dot
products</tt></td>
</tr>
<tr class="c3">
<td><tt>01:12.36</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>they probably thought it made sense at the
time</tt></td>
</tr>
<tr class="c3">
<td><tt>01:13.03</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>i think the x86 was based on some processor
that was in turn based on another processor that was an accumulator
architecture</tt></td>
</tr>
<tr class="c3">
<td><tt>01:13.04</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>only one register</tt></td>
</tr>
<tr class="c3">
<td><tt>01:13.37</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Right... Someone somewhere should have figured
out that we needed to clean up that crap when the ISA went 32 bits,
then 64 bits</tt></td>
</tr>
<tr class="c3">
<td><tt>01:13.43</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>they prolly thought it would be more
orthogonal and kept doing that crap when they added
registers</tt></td>
</tr>
<tr class="c3">
<td><tt>01:13.53</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>And now, it's stuck with us forever since
there won't be a 128 bits</tt></td>
</tr>
<tr class="c3">
<td><tt>01:13.59</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>the 64bits cleaned it up a teensy bit i
think</tt></td>
</tr>
<tr class="c3">
<td><tt>01:14.16</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>who knows...</tt></td>
</tr>
<tr class="c3">
<td><tt>01:14.55</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Oh actually, the inc/dec mess did become
prefixes on 64 bits</tt></td>
</tr>
<tr class="c3">
<td><tt>01:15.02</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>see</tt></td>
</tr>
<tr class="c3">
<td><tt>01:15.13</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>yeah i think they reused one of two of those
instructions</tt></td>
</tr>
<tr class="c3">
<td><tt>01:15.26</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>the VEX prefit or whatever. or was it
REX.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:15.28</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Right</tt></td>
</tr>
<tr class="c3">
<td><tt>01:15.44</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>They still should have cleaned up a little
more, but eh</tt></td>
</tr>
<tr class="c3">
<td><tt>01:16.01</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>well</tt></td>
</tr>
<tr class="c3">
<td><tt>01:16.18</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>AMD had the prior experience with the
Technical Floating Point extensions</tt></td>
</tr>
<tr class="c3">
<td><tt>01:16.41</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>from what i heard the compiler writers and OS
writers (prolly MS) didn't want to add support</tt></td>
</tr>
<tr class="c3">
<td><tt>01:16.51</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>so they dropped it and implemented
compatibility with SSE</tt></td>
</tr>
<tr class="c3">
<td><tt>01:16.55</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>2</tt></td>
</tr>
<tr class="c3">
<td><tt>01:16.58</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Never heard of that before. Is it
3dnow?...</tt></td>
</tr>
<tr class="c3">
<td><tt>01:17.03</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>no</tt></td>
</tr>
<tr class="c3">
<td><tt>01:17.11</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>it was three operand floating point ala
RISC</tt></td>
</tr>
<tr class="c3">
<td><tt>01:17.23</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>non-vector</tt></td>
</tr>
<tr class="c3">
<td><tt>01:17.43</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Google isn't finding much either</tt></td>
</tr>
<tr class="c3">
<td><tt>01:18.06</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt><a href=
"http://arstechnica.com/civis/viewtopic.php?f=8&amp;t=530111">http://arstechnica.com/civis/viewtopic.php?f=8&amp;t=530111</a></tt></td>
</tr>
<tr class="c3">
<td><tt>01:18.32</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>the big thing was the FMA support</tt></td>
</tr>
<tr class="c3">
<td><tt>01:18.35</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>IIRC</tt></td>
</tr>
<tr class="c3">
<td><tt>01:18.39</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>three operand FMA</tt></td>
</tr>
<tr class="c3">
<td><tt>01:19.24</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>it would have doubled peak FP performance on
x86 vs x87 i think</tt></td>
</tr>
<tr class="c3">
<td><tt>01:19.36</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>and coz of no more stack the performance would
also be better</tt></td>
</tr>
<tr class="c3">
<td><tt>01:19.37</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Cool, thanks</tt></td>
</tr>
<tr class="c3">
<td><tt>01:19.46</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>they eventually gave up</tt></td>
</tr>
<tr class="c3">
<td><tt>01:19.58</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>AMD preferred to follow Intel on the SSE
path</tt></td>
</tr>
<tr class="c3">
<td><tt>01:20.35</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>they had the experience with 3dnow</tt></td>
</tr>
<tr class="c3">
<td><tt>01:20.39</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>and 3dnow!</tt></td>
</tr>
<tr class="c3">
<td><tt>01:20.55</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>it's hard to convince software
writers</tt></td>
</tr>
<tr class="c3">
<td><tt>01:21.04</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>the tools guys</tt></td>
</tr>
<tr class="c3">
<td><tt>01:21.19</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>so they gave up and went the SSE, whatever
way</tt></td>
</tr>
<tr class="c3">
<td><tt>01:21.44</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>had they done the TFP i think X87 FP on 64-bit
mode would be dead</tt></td>
</tr>
<tr class="c3">
<td><tt>01:22.05</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>They should have thrown the x87 out on 64
bits</tt></td>
</tr>
<tr class="c3">
<td><tt>01:22.21</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>well the ISA says that SSE is the default FP
mode</tt></td>
</tr>
<tr class="c3">
<td><tt>01:22.29</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>i think</tt></td>
</tr>
<tr class="c3">
<td><tt>01:22.35</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>SSE2 actually</tt></td>
</tr>
<tr class="c3">
<td><tt>01:22.35</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Yes...</tt></td>
</tr>
<tr class="c3">
<td><tt>01:22.46</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>But the x87 is taking a *ton* of precious 1
byte opcodes!</tt></td>
</tr>
<tr class="c3">
<td><tt>01:22.56</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Seriously, like 40 of them</tt></td>
</tr>
<tr class="c3">
<td><tt>01:22.57</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>does it have those?</tt></td>
</tr>
<tr class="c3">
<td><tt>01:23.02</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Yes</tt></td>
</tr>
<tr class="c3">
<td><tt>01:23.11</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>i mean it was designed by those guys at Intel
Haifa as an afterthought</tt></td>
</tr>
<tr class="c3">
<td><tt>01:23.25</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>let the Israelis do this crap no one
needs</tt></td>
</tr>
<tr class="c3">
<td><tt>01:24.00</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>i think they had a limited opcode space so
they went with that stack abortion ISA as a compromise</tt></td>
</tr>
<tr class="c3">
<td><tt>01:24.28</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Hum yes, it's just 16 one-byte opcodes after
all, 0xD*</tt></td>
</tr>
<tr class="c3">
<td><tt>01:24.53</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>They play in bits in the ModRM byte to change
the instructions</tt></td>
</tr>
<tr class="c3">
<td><tt>01:25.56</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Since an operand is always the first x87
register on top of the stack, they have an extra 3 bits for every
one-byte opcode</tt></td>
</tr>
<tr class="c3">
<td><tt>01:26.06</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>So each one-byte opcode actually holds 8
different instructions</tt></td>
</tr>
<tr class="c3">
<td><tt>01:26.15</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>It's both clever and incredibly
nasty</tt></td>
</tr>
<tr class="c3">
<td><tt>01:26.50</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>it must make that instruction decoder really
swell to do</tt></td>
</tr>
<tr class="c3">
<td><tt>01:28.26</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>What a mess, 3 bits of the byte that
identifies register operands actually change the
instruction</tt></td>
</tr>
<tr class="c3">
<td><tt>01:28.43</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt><span class="c7">wouldn't want work in x86 CPU
design</span></tt></td>
</tr>
<tr class="c3">
<td><tt>01:29.15</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>it's crap piled on more crap</tt></td>
</tr>
<tr class="c3">
<td><tt>01:29.54</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>like i said only i386 and x86-64 provide some
reprieve</tt></td>
</tr>
<tr class="c3">
<td><tt>01:30.12</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>even if its still suboptimally
encoded</tt></td>
</tr>
<tr class="c3">
<td><tt>01:30.41</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>You are certainly right that they designed
that whole x87 stack because they didn't have enough opcode
space</tt></td>
</tr>
<tr class="c3">
<td><tt>01:30.52</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>It shows just by reading the instruction
encoding</tt></td>
</tr>
<tr class="c3">
<td><tt>01:31.50</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>stack processors were actually a fad at one
point. actually several points.</tt></td>
</tr>
<tr class="c3">
<td><tt>01:32.03</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>latest was prolly the java processor
crap</tt></td>
</tr>
<tr class="c3">
<td><tt>01:32.10</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>picojava</tt></td>
</tr>
<tr class="c3">
<td><tt>01:32.53</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>I completely fail to see any advantage, except
perhaps higher instruction encoding density due to an implicit
argument</tt></td>
</tr>
<tr class="c3">
<td><tt>01:33.09</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>yeah that's the usual</tt></td>
</tr>
<tr class="c3">
<td><tt>01:33.12</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>But you could have the same thing with regular
registers, a very fast xchg and implicit eax instructions</tt></td>
</tr>
<tr class="c3">
<td><tt>01:37.09</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>i don't think CISC is necessarily a bad
idea</tt></td>
</tr>
<tr class="c3">
<td><tt>01:37.16</tt></td>
<td><span class="c9"><tt>vasc__</tt></span></td>
<td width="100%"><tt>but X86 is a bad CISC</tt></td>
</tr>
<tr class="c3">
<td><tt>01:37.46</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>CISC should never have hardcoded
registers</tt></td>
</tr>
<tr class="c3">
<td><tt>01:38.12</tt></td>
<td><span class="c2"><tt>Stragus</tt></span></td>
<td width="100%"><tt>And CISC should implement useful instructions
for the future, no whatever Intel found easier/cheaper to implement
at that point in time</tt></td>
</tr>
<tr>
<td><tt>05:17.00</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad merzo
(~merzo@38-109-133-95.pool.ukrtel.net)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>06:32.51</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65927
brlcad/branches/opencl/src/rt/do.c: fix pointer bugs in the hlbvh
builder. change max leaf size to 4 solids.</tt></td>
</tr>
<tr>
<td><tt>07:33.05</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad merzo
(~merzo@134-32-133-95.pool.ukrtel.net)</span></tt></td>
</tr>
<tr>
<td><tt>08:01.24</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad roop
(~roop@106.76.156.16)</span></tt></td>
</tr>
<tr>
<td><tt>08:39.10</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad merzo
(~merzo@140-107-132-95.pool.ukrtel.net)</span></tt></td>
</tr>
<tr>
<td><tt>09:15.54</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad merzo
(~merzo@109-52-133-95.pool.ukrtel.net)</span></tt></td>
</tr>
<tr>
<td><tt>09:43.55</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad shaina
(~shaina@61.0.200.41)</span></tt></td>
</tr>
<tr>
<td><tt>10:32.10</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad ries
(~ries@D979C47E.cm-3-2d.dynamic.ziggo.nl)</span></tt></td>
</tr>
<tr>
<td><tt>10:39.40</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad ries
(~ries@D979C47E.cm-3-2d.dynamic.ziggo.nl)</span></tt></td>
</tr>
<tr>
<td><tt>10:52.02</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad dracarys983
(dracarys98@nat/iiit/x-qeyccaegxmasrrzf)</span></tt></td>
</tr>
<tr>
<td><tt>11:30.14</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad konrado
(~konro@41.205.22.10)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>13:25.42</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:ejno * 65928
(brlcad/trunk/src/libgcv/bot_solidity.c
brlcad/trunk/src/libgcv/plugin.c brlcad/trunk/src/libgcv/plugin.h):
formatting; use const pointers</tt></td>
</tr>
<tr class="c3">
<td><tt>14:47.12</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65929
(brlcad/branches/opencl/include/rt/shoot.h
brlcad/branches/opencl/src/librt/primitives/primitive_util.c
brlcad/branches/opencl/src/rt/do.c): refactor hlbvh api.</tt></td>
</tr>
<tr>
<td><tt>15:42.40</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad konrado
(~konro@41.205.22.32)</span></tt></td>
</tr>
<tr>
<td><tt>15:47.29</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad vasc
(~vasc@bl13-126-172.dsl.telepac.pt)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>15:53.15</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65930
(brlcad/branches/opencl/include/bu/malloc.h
brlcad/branches/opencl/src/libbu/malloc.c
brlcad/branches/opencl/src/rt/do.c): memory pools to manage bvh
node creation memory.</tt></td>
</tr>
<tr class="c3">
<td><tt>15:59.30</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65931
(brlcad/trunk/include/bu/malloc.h brlcad/trunk/src/libbu/malloc.c):
memory pools.</tt></td>
</tr>
<tr class="c3">
<td><tt>16:12.09</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65932
(brlcad/trunk/include/rt/shoot.h
brlcad/trunk/src/librt/primitives/arb8/arb8_shot.cl and 9 others):
opencl linear bvh traversal.</tt></td>
</tr>
<tr class="c3">
<td><tt>16:26.30</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>bhollister3: apologies for not being around on
Fri - didn't have internet access</tt></td>
</tr>
<tr>
<td><tt>16:45.28</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad gurwinder
(~chatzilla@59.91.237.53)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>17:02.13</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:ejno * 65933
brlcad/trunk/src/librt/primitives/bot/gct_decimation/meshdecimation.c:
silence warning</tt></td>
</tr>
<tr class="c3">
<td><tt>17:15.48</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:starseeker * 65934
(brlcad/trunk/src/libged/brep.c
brlcad/trunk/src/librt/primitives/brep/brep_debug.cpp): Add support
for custom colors to a few more brep plotting routines.</tt></td>
</tr>
<tr class="c3">
<td><tt>17:18.28</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>konrado: if we're going to require that libxml
be installed, it'll need to move to src/other</tt></td>
</tr>
<tr class="c3">
<td><tt>17:18.38</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>konrado: (sorry, catching up)</tt></td>
</tr>
<tr class="c3">
<td><tt>17:25.38</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>konrado: did you happen to take a look at
irrXML as used by assimp?  <a href=
"https://github.com/assimp/assimp/tree/master/contrib/irrXML">https://github.com/assimp/assimp/tree/master/contrib/irrXML</a></tt></td>
</tr>
<tr class="c3">
<td><tt>17:26.08</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>konrado: if that can do what is needed, I
suspect it would be a much simpler dependency to manage than libxml
et. al.</tt></td>
</tr>
<tr class="c3">
<td><tt>17:28.21</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>would need slight rework to make it "properly"
contained but since assimp is using their version in geometry file
conversion it will hopefully be well matched to our own
needs</tt></td>
</tr>
<tr>
<td><tt>17:34.57</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad konrado_
(~konro@41.205.22.38)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>17:37.10</tt></td>
<td><span class="c11"><tt>konrado</tt></span></td>
<td width="100%"><tt>starseeker: Thanks for the   response, I would
look into all what you have said and get back to you
latter.</tt></td>
</tr>
<tr class="c3">
<td><tt>17:37.35</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>konrado: if we do need libxml we can do that,
but it's likely going to require more build work than just adding
install rules</tt></td>
</tr>
<tr class="c3">
<td><tt>17:38.20</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>iirc there was quite a lot in there, and the
existing CMake files are targeted solely at getting enough of it
working to do our docbook build and validation in a cross platform
fashion</tt></td>
</tr>
<tr class="c3">
<td><tt>17:39.04</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>I'd want to do a more thorough job of it if
libxml graduates to an installed 3rd party src/other dep</tt></td>
</tr>
<tr class="c3">
<td><tt>17:39.47</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>konrado: if it would help for me to break out
a stand-alone version of the assimp irrxml fork I can probably do
that fairly quickly - let me know</tt></td>
</tr>
<tr>
<td><tt>17:43.04</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad konro__
(~konro@41.205.22.43)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>17:44.43</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>sxmlc might also be worth a look if irrXML
proves inadequate for some reason - it seems to be
maintained</tt></td>
</tr>
<tr class="c3">
<td><tt>17:45.10</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt>but assimp's needs are likely to map very well
to ours in this area</tt></td>
</tr>
<tr class="c3">
<td><tt>17:45.55</tt></td>
<td><span class="c10"><tt>starseeker</tt></span></td>
<td width="100%"><tt><span class="c7">is still partial to the idea
of hooking them under libgcv to handle bot
formats...</span></tt></td>
</tr>
<tr>
<td><tt>18:10.06</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad bhollister
(~brad@2601:647:cb01:9750:b530:224b:6c3:7974)</span></tt></td>
</tr>
<tr>
<td><tt>18:21.47</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad konrado
(~konro@41.205.22.12)</span></tt></td>
</tr>
<tr>
<td><tt>18:34.10</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad ries_nicked
(~ries@D979C47E.cm-3-2d.dynamic.ziggo.nl)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>18:34.50</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65935
brlcad/branches/opencl/src/rt/do.c: remove experimental grids
code.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:37.05</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD Wiki:Gurwinder Singh * 9356
/wiki/User:Gurwinder_Singh/GSoc15/log_developmen:</tt></td>
</tr>
<tr class="c3">
<td><tt>18:42.30</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD Wiki:Gurwinder Singh * 9357
/wiki/Povray:</tt></td>
</tr>
<tr class="c3">
<td><tt>18:43.18</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD Wiki:Gurwinder Singh * 9358
/wiki/Povray:</tt></td>
</tr>
<tr class="c3">
<td><tt>20:05.06</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD Wiki:106.76.158.73 * 9359
/wiki/User:Hiteshsofat/GSoc15/log_developmen:</tt></td>
</tr>
<tr class="c3">
<td><tt>20:34.47</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65936
brlcad/branches/opencl/src/rt/do.c: refactor bvh builder to accept
a list of centroids and boxes instead of primitives.</tt></td>
</tr>
<tr>
<td><tt>20:49.22</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad gaganjyot
(~vikram@117.253.227.160)</span></tt></td>
</tr>
<tr>
<td><tt>20:57.27</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad Ch3ck_
(~Ch3ck@41.205.19.154)</span></tt></td>
</tr>
<tr>
<td><tt>21:54.30</tt></td>
<td colspan="2"><tt><span class="c12">*** part/#brlcad Ch3ck_
(~Ch3ck@41.205.19.154)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>22:03.08</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65937
(brlcad/branches/opencl/include/rt/defines.h
brlcad/branches/opencl/include/rt/shoot.h and 3 others): move bvh
builder to librt.</tt></td>
</tr>
<tr class="c3">
<td><tt>22:19.54</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65938
(brlcad/trunk/include/rt/defines.h brlcad/trunk/include/rt/shoot.h
and 2 others): add hlbvh cpu builder to trunk.</tt></td>
</tr>
<tr class="c3">
<td><tt>22:28.35</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:vasco_costa * 65939
brlcad/branches/opencl/src/librt/cut.c: improve comments.</tt></td>
</tr>
<tr class="c3">
<td><tt>22:32.11</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD Wiki:Vasco.costa * 9360
/wiki/User:Vasco.costa/GSoC15/logs: /* Week 12 : 10 Aug-16 Aug
*/</tt></td>
</tr>
<tr class="c3">
<td><tt>22:32.54</tt></td>
<td><span class="c4"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD Wiki:Vasco.costa * 9361
/wiki/User:Vasco.costa/GSoC15/logs: /* Development Status
*/</tt></td>
</tr>
</table>
<br />
Generated by irclog2html.pl Modified by <a href=
"http://Rikers.org">Tim Riker</a> to work with <a href=
"http://infobot.sourceforge.net/">infobot</a>.
</body>
</html>
