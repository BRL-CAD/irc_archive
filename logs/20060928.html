<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.6.0" />
<title>irclog2html for #brlcad on 20060928</title>
<meta name="generator" content="irclog2html.pl by Jeff Waugh" />
<meta name="version" content="Version 1.5 - 11th May 2000" />
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<style type="text/css">
/*<![CDATA[*/
 body {
  background-color: #FFFFFF;
  color: #000000;
 }
 span.c7 {color: #E27777}
 span.c6 {color: #C76868}
 span.c5 {color: #C4C467}
 span.c4 {color: #71D7D7}
 tr.c3 {background-color: #EEEEEE}
 span.c2 {color: #5B5BAD}
 span.c1 {color: #009900}
/*]]>*/
</style>
</head>
<body>
<h1>irclog2html for #brlcad on 20060928</h1>
<table cellspacing="3" cellpadding="2" border="0">
<tr>
<td><tt>01:00.10</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad DTRemenak
(n=DTRemena@adsl-68-126-0-210.dsl.irvnca.pacbell.net)</span></tt></td>
</tr>
<tr>
<td><tt>03:01.12</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad digitalfredy
(n=digitalf@200.71.62.161)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>03:09.40</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That 1.7 million triangles frigate really
kills the raytracing performance, with all its diagonal ropes
through the scene. Very stressfull test for a raytracer... I would
be interested in knowing how my 200mb of RAM use on this compares
with ADRT</tt></td>
</tr>
<tr class="c3">
<td><tt>03:10.44</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Or 400mb if I push the quality ( and
performance ) high</tt></td>
</tr>
<tr class="c3">
<td><tt>03:19.04</tt></td>
<td><span class="c4"><tt>CIA-9</tt></span></td>
<td width="100%"><tt>BRL-CAD: 03brlcad * 10brlcad/sh/ (footer.sh
header.sh): add support for C++ and Objective-C/C++ to the
mix</tt></td>
</tr>
<tr>
<td><tt>04:04.52</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad digitalfredy
(n=digitalf@200.71.62.161)</span></tt></td>
</tr>
<tr>
<td><tt>04:05.19</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad dan_falck
(n=danfalck@pool-71-111-76-8.ptldor.dsl-w.verizon.net)</span></tt></td>
</tr>
<tr>
<td><tt>04:19.38</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad IriX64
(n=Who@bas3-sudbury98-1168052970.dsl.bell.ca)</span></tt></td>
</tr>
<tr>
<td><tt>04:54.19</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad DTRemenak
(n=DTRemena@adsl-68-126-0-210.dsl.irvnca.pacbell.net)</span></tt></td>
</tr>
<tr>
<td><tt>05:46.36</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad clock_
(i=clock@84-72-60-185.dclient.hispeed.ch)</span></tt></td>
</tr>
<tr>
<td><tt>07:20.50</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad clock_
(n=clock@zux221-122-143.adsl.green.ch)</span></tt></td>
</tr>
<tr>
<td><tt>11:20.58</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad rossberg
(n=rossberg@bz.bzflag.bz)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>11:54.20</tt></td>
<td><span class="c4"><tt>CIA-9</tt></span></td>
<td width="100%"><tt>BRL-CAD: 03d_rossberg * 10brlcad/BUGS: fixed
rendering toyjeep.g on Windows bug (on 7/6/2006) by using a less
rigorouse function to invert a 4x4 matrix in
rt_bend_pipe_prep</tt></td>
</tr>
<tr>
<td><tt>12:35.38</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad Twingy
(n=justin@74.92.144.217)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>13:04.20</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Does anyone have a recommendation for the best
reference for doxygen comments in the BRL-CAD code?</tt></td>
</tr>
<tr class="c3">
<td><tt>13:05.14</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I noticed Lee working on libuu's doxygen
documentation, though I'm not sure where that libuu is. Not much
comes out on find</tt></td>
</tr>
<tr class="c3">
<td><tt>13:05.56</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Ah, or perhaps it was libbu</tt></td>
</tr>
<tr class="c3">
<td><tt>14:01.31</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Eh, Doxygen is confused about GCC's
__attribute__()</tt></td>
</tr>
<tr class="c3">
<td><tt>14:22.54</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>O.o</tt></td>
</tr>
<tr class="c3">
<td><tt>14:24.44</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Feeling any better, Erik?</tt></td>
</tr>
<tr class="c3">
<td><tt>14:34.32</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>not much, heh</tt></td>
</tr>
<tr class="c3">
<td><tt>14:35.00</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>:/ Did you go through a x-ray scan just to
make sure?</tt></td>
</tr>
<tr class="c3">
<td><tt>14:38.24</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>yeah, several xrays and a catscan</tt></td>
</tr>
<tr class="c3">
<td><tt>14:38.50</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>btw, I think I may have an idea on why your
code doesn't run so hot on g4/g5 ... gcc 4.0.0</tt></td>
</tr>
<tr class="c3">
<td><tt>14:39.20</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Oh hum, that's a possibility. The assembly
looked very poor, as little as I know that arch</tt></td>
</tr>
<tr class="c3">
<td><tt>14:39.49</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The demo now loads the 1.7 million triangles
frigate with caching, if you want</tt></td>
</tr>
<tr class="c3">
<td><tt>14:40.19</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>yeah, been building for a few
minutes</tt></td>
</tr>
<tr class="c3">
<td><tt>14:40.23</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it segfaults on my amd64</tt></td>
</tr>
<tr class="c3">
<td><tt>14:40.35</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>#0  0x0000000801758c88 in stepComputeValue
(step=0x522030) at ../../../RF/prepmodel.c:701</tt></td>
</tr>
<tr class="c3">
<td><tt>14:40.35</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>701       step-&gt;linkcost[RF_EDGE_MAXZ] =
WALK_LINKCOUNT_COST( step-&gt;linkcount[ RF_EDGE_MAXZ ]
);</tt></td>
</tr>
<tr class="c3">
<td><tt>14:40.44</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Hum. Okay</tt></td>
</tr>
<tr class="c3">
<td><tt>14:41.34</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I seriously need to speed up that prep
eventually, it does a decent job but isn't fast at it</tt></td>
</tr>
<tr class="c3">
<td><tt>14:42.29</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Could you  p step-&gt;linkcount[ RF_EDGE_MAXZ
]  on that segfault? It's rather curious</tt></td>
</tr>
<tr class="c3">
<td><tt>14:44.33</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Even with low preparation quality, the 'prep'
can eat up to 500mb ; if it takes minutes, I think you are
swapping...</tt></td>
</tr>
<tr class="c3">
<td><tt>14:50.23</tt></td>
<td><span class="c6"><tt>brlcad</tt></span></td>
<td width="100%"><tt>src/lib*, there's a list of what each of the
various libs do in HACKING and src/README</tt></td>
</tr>
<tr class="c3">
<td><tt>14:51.11</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I was more looking for the best reference for
the desired doxygen comment style, rather than a specific
library</tt></td>
</tr>
<tr class="c3">
<td><tt>14:54.48</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it's consuming one whole cpu, 508.19m real,
719.54m virtual, and has been going for 22 minutes</tt></td>
</tr>
<tr class="c3">
<td><tt>14:54.55</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Thanks Erik, bug reproductible if I fill all
malloc'ed memory with garbage</tt></td>
</tr>
<tr class="c3">
<td><tt>14:55.09</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>mal: yet another linux vs restoftheworld type
issue</tt></td>
</tr>
<tr class="c3">
<td><tt>14:55.28</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Woah, it takes less than a minute on a good
Athlon</tt></td>
</tr>
<tr class="c3">
<td><tt>14:56.10</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I got 1.3m r/s with the m1 a couple days
ago</tt></td>
</tr>
<tr class="c3">
<td><tt>14:56.27</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I'm wondering if maybe it's caught in an
infinite loop due to different rounding behaviors or
something</tt></td>
</tr>
<tr class="c3">
<td><tt>14:56.33</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I got 2.5-3.0m on my desktop, but the frigate
is much more demanding</tt></td>
</tr>
<tr class="c3">
<td><tt>14:56.55</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That shouldn't happen, then again, I might
have missed something in this new prep written from
scratch</tt></td>
</tr>
<tr class="c3">
<td><tt>14:56.58</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>oh, and *HUGE* stalls on some ops,
heh</tt></td>
</tr>
<tr class="c3">
<td><tt>14:57.09</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>but I think it's a compiler problem more than
anything else :/</tt></td>
</tr>
<tr class="c3">
<td><tt>14:57.20</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>and stupid darwinports won't compile
gcc42</tt></td>
</tr>
<tr class="c3">
<td><tt>14:58.01</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Yes, the dotproduct4 assembly code was loading
all the values just before working on them, instead of scheduling a
bit</tt></td>
</tr>
<tr class="c3">
<td><tt>14:58.30</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hm, 'real' memory dropped a bit and is
creaping back up</tt></td>
</tr>
<tr class="c3">
<td><tt>14:58.33</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it must still be doing SOMETHING</tt></td>
</tr>
<tr class="c3">
<td><tt>14:58.36</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>uh</tt></td>
</tr>
<tr class="c3">
<td><tt>14:58.38</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Ahah</tt></td>
</tr>
<tr class="c3">
<td><tt>14:58.42</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>you don't do something like realloc in that
prep, do you?</tt></td>
</tr>
<tr class="c3">
<td><tt>14:59.04</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Very rarely, but it will happen</tt></td>
</tr>
<tr class="c3">
<td><tt>14:59.08</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hrm</tt></td>
</tr>
<tr class="c3">
<td><tt>14:59.30</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it's horrendously expensive on the bsd family
since phkmalloc and dmalloc work differently</tt></td>
</tr>
<tr class="c3">
<td><tt>14:59.32</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I realloc the table of pages for pointer
directories, for sectors/steps/nodes</tt></td>
</tr>
<tr class="c3">
<td><tt>14:59.37</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I see.</tt></td>
</tr>
<tr class="c3">
<td><tt>15:00.20</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>phkmalloc tries to keep things more secure
from mmu smashes, so it tries to force memory to be contiguous on
the wire, which means a realloc is an ugly naive alloc/copy/dealloc
instead of dmalloc's page mangling</tt></td>
</tr>
<tr class="c3">
<td><tt>15:00.33</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Gah!</tt></td>
</tr>
<tr class="c3">
<td><tt>15:00.44</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>MOST unix has a very very slow
realloc</tt></td>
</tr>
<tr class="c3">
<td><tt>15:01.42</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>but mallocing more than you need is 'free', it
won't actually hit wire until it's written to, so malloc 2g, use
what you want, don't worry about it *shrug* :)</tt></td>
</tr>
<tr class="c3">
<td><tt>15:02.28</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Then it's swapping around happily, hence why
it takes 22 minutes instead of 40 seconds</tt></td>
</tr>
<tr class="c3">
<td><tt>15:02.56</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>swap is totally unused right now</tt></td>
</tr>
<tr class="c3">
<td><tt>15:03.15</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>What is system doing?</tt></td>
</tr>
<tr class="c3">
<td><tt>15:03.21</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I d'no *shrug*</tt></td>
</tr>
<tr class="c3">
<td><tt>15:03.37</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>you're making system calls (wrapped via libc
calls, I'm sure) that are expensive</tt></td>
</tr>
<tr class="c3">
<td><tt>15:04.04</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>There are no system calls but
malloc/free/realloc in there</tt></td>
</tr>
<tr class="c3">
<td><tt>15:04.19</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>malloc and free should be fast</tt></td>
</tr>
<tr class="c3">
<td><tt>15:04.21</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>there it is</tt></td>
</tr>
<tr class="c3">
<td><tt>15:04.24</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>realloc is dog slow</tt></td>
</tr>
<tr class="c3">
<td><tt>15:04.44</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>It's really realloc? The one in mmDir* in mm.c
?</tt></td>
</tr>
<tr class="c3">
<td><tt>15:07.33</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hrm, in the raytrace porttion, 9.6% of the
time is spent on one op... "cror" (but it's stalled pretty
heavy)</tt></td>
</tr>
<tr class="c3">
<td><tt>15:08.16</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>In the dot product again? :)</tt></td>
</tr>
<tr class="c3">
<td><tt>15:08.54</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>graphTraceDualOut line 635, the
"if(dstdist&lt;=0.0)", which looks like it has to do two sequential
tests and then or the results before choosing to branch</tt></td>
</tr>
<tr class="c3">
<td><tt>15:09.37</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>so to the machine, it looks like "if(
dstdist&lt;0.0 || dstdist==0.0 )", requiring both to get out of the
pipeline, then feed back in for the or? *shrug*</tt></td>
</tr>
<tr class="c3">
<td><tt>15:09.52</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That's quite possible, weird chip you
got</tt></td>
</tr>
<tr class="c3">
<td><tt>15:09.53</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>vs if(!(dstdir&gt;0.0)) which can be
streamed</tt></td>
</tr>
<tr class="c3">
<td><tt>15:09.58</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it's risc *shrug*</tt></td>
</tr>
<tr class="c3">
<td><tt>15:10.12</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>dstdist &lt; 0.0 if you prefer, won't make a
difference</tt></td>
</tr>
<tr class="c3">
<td><tt>15:10.32</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I'm kinda guessing based on what the little
comment in shark says, heh</tt></td>
</tr>
<tr class="c3">
<td><tt>15:10.48</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Yes I remember</tt></td>
</tr>
<tr class="c3">
<td><tt>15:10.50</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>14% of compute time is on that dstdis =
_mathPlanePoint(tri-&gt;plane, dst) on 634</tt></td>
</tr>
<tr class="c3">
<td><tt>15:11.22</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>'</tt></td>
</tr>
<tr class="c3">
<td><tt>15:11.24</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>gheh</tt></td>
</tr>
<tr class="c3">
<td><tt>15:12.29</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>So I suppose it finished prep'in in the end.
Care to profile that part?..</tt></td>
</tr>
<tr class="c3">
<td><tt>15:12.48</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I can't see what would take so long, as lazy
as some of the code is</tt></td>
</tr>
<tr class="c3">
<td><tt>15:15.37</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>If you do so, make sure to delete the cache or
it will just load it</tt></td>
</tr>
<tr class="c3">
<td><tt>15:24.40</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>sure, uh, I'll gzip the cache instead,
heh...</tt></td>
</tr>
<tr class="c3">
<td><tt>15:24.55</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>rtch ?</tt></td>
</tr>
<tr class="c3">
<td><tt>15:24.58</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Right</tt></td>
</tr>
<tr class="c3">
<td><tt>15:25.13</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>100 meg file, huh</tt></td>
</tr>
<tr class="c3">
<td><tt>15:25.55</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I was aiming for a bit packed version earlier,
I'll switch back to that later</tt></td>
</tr>
<tr class="c3">
<td><tt>15:26.19</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>( So if you need 13 bits to identify a sector,
it will use that instead of 32 bits )</tt></td>
</tr>
<tr class="c3">
<td><tt>15:26.46</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>interesting, it starts very user based, and
linearly ramps to very system based</tt></td>
</tr>
<tr class="c3">
<td><tt>15:27.21</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Anything more precise on what's going on in
system?</tt></td>
</tr>
<tr class="c3">
<td><tt>15:29.49</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>"shandler" sounds familiar?</tt></td>
</tr>
<tr class="c3">
<td><tt>15:31.03</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Hum, no?</tt></td>
</tr>
<tr class="c3">
<td><tt>15:32.25</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>only 15.6 spend outside of
mach_kernel</tt></td>
</tr>
<tr class="c3">
<td><tt>15:32.48</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>the biggest single symbol being
vm_map_enter</tt></td>
</tr>
<tr class="c3">
<td><tt>15:33.02</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>which kinda smells like lots of small
alloc's</tt></td>
</tr>
<tr class="c3">
<td><tt>15:33.33</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>O.O  holy forshizzle</tt></td>
</tr>
<tr class="c3">
<td><tt>15:33.56</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>chunk-&gt;prev = (void *)&amp;(mmList); is
greviously expensive, if I'm reading this right</tt></td>
</tr>
<tr class="c3">
<td><tt>15:34.18</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>But... how?</tt></td>
</tr>
<tr class="c3">
<td><tt>15:34.27</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>stw r0,12(r3)</tt></td>
</tr>
<tr class="c3">
<td><tt>15:35.24</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>okie, readin that wrong...</tt></td>
</tr>
<tr class="c3">
<td><tt>15:35.48</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>of the 3% of program time, that op was the big
consumer there... still less than 3% total</tt></td>
</tr>
<tr class="c3">
<td><tt>15:36.07</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>:) I prefer that</tt></td>
</tr>
<tr class="c3">
<td><tt>15:53.44</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>*shrug* comments and docs would allow other
people to understand your stuff more readily and maybe make
comments on possible concerns or bottlenecks that you'd otherwise
spend a lot of time tracking</tt></td>
</tr>
<tr class="c3">
<td><tt>15:53.55</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>especially since your environment is pretty
homogenous</tt></td>
</tr>
<tr class="c3">
<td><tt>15:54.31</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I wanted to try Justin's fbsd box but it only
has 256mb of ram</tt></td>
</tr>
<tr class="c3">
<td><tt>15:55.22</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>mine only has 384, heh</tt></td>
</tr>
<tr class="c3">
<td><tt>15:55.39</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>my home one, that is</tt></td>
</tr>
<tr class="c3">
<td><tt>15:56.17</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I just tried profiling in gprof, and it
doesn't profile anything in shared libraries :p, so I profiled my
main.c</tt></td>
</tr>
<tr class="c3">
<td><tt>15:56.45</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>you need to build profiling forms of the
shared libraries</tt></td>
</tr>
<tr class="c3">
<td><tt>15:57.06</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>uhmmm, on fbsd, you'd see like libc.so and
libc_p.so where _p.so is for the profiling lib</tt></td>
</tr>
<tr class="c3">
<td><tt>15:57.25</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I'm too out of leenewx to remember there,
heh</tt></td>
</tr>
<tr class="c3">
<td><tt>15:57.26</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Shared libraries were built with -pg as well,
anything else?</tt></td>
</tr>
<tr class="c3">
<td><tt>15:58.47</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Any sensitive results out of Sharp?</tt></td>
</tr>
<tr class="c3">
<td><tt>16:01.50</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>"Support for gprof profiling of shared
libraries is available on 32-bit systems only."   What
the...</tt></td>
</tr>
<tr class="c3">
<td><tt>16:02.20</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Sorry, nevermind that, specific to
HP-Unix</tt></td>
</tr>
<tr class="c3">
<td><tt>16:02.22</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>shark? I don't think I ran it right, so I'm
rerunning it :/</tt></td>
</tr>
<tr class="c3">
<td><tt>16:06.12</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>stepSampleSort is a bit pricey</tt></td>
</tr>
<tr class="c3">
<td><tt>16:06.56</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Like 5% or 40%?</tt></td>
</tr>
<tr class="c3">
<td><tt>16:07.05</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>22.6</tt></td>
</tr>
<tr class="c3">
<td><tt>16:07.31</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Okay. That's one of the thing I have marked to
fix, I'm more wondering about the time spent on "system"</tt></td>
</tr>
<tr class="c3">
<td><tt>16:08.27</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>sampleAddTri() is a tiny bit expensive,
...</tt></td>
</tr>
<tr class="c3">
<td><tt>16:09.30</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Yes... and I'm not even using these lists yet,
planning ahead for improvements of the prep</tt></td>
</tr>
<tr class="c3">
<td><tt>16:10.28</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Can you throw all the profiling text at
me?</tt></td>
</tr>
<tr class="c3">
<td><tt>16:12.01</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>uhmmmmm, I'm running another set with
different time variables</tt></td>
</tr>
<tr class="c3">
<td><tt>16:35.39</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>So 50% is spent outside the executable itself,
that's... cute ;)</tt></td>
</tr>
<tr class="c3">
<td><tt>16:36.39</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I d'no if that's because it's a single thread
on a dual proc machine, or if it's just not seeing the frame stack
correctly when it samples, or if sdl throws threads, or
what</tt></td>
</tr>
<tr class="c3">
<td><tt>16:39.42</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The model is built before SDL is initialized,
and you mentionned the system share starts growing later
on</tt></td>
</tr>
<tr class="c3">
<td><tt>16:40.06</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hm, part of sdl is initialized before main()
iirc</tt></td>
</tr>
<tr class="c3">
<td><tt>16:40.20</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it immediately pops up an sdl icon in the
doc</tt></td>
</tr>
<tr class="c3">
<td><tt>16:40.23</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>before the window appears</tt></td>
</tr>
<tr class="c3">
<td><tt>16:40.24</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>dock</tt></td>
</tr>
<tr class="c3">
<td><tt>16:41.17</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Right I see</tt></td>
</tr>
<tr class="c3">
<td><tt>16:47.26</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I think I would know how to build shared
libraries for gprof'iling, except that everything goes though this
libtool thing</tt></td>
</tr>
<tr class="c3">
<td><tt>16:48.33</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>yeah, I'm not terribly keen on libtool, but
dynamic libraries are different on every os :/</tt></td>
</tr>
<tr class="c3">
<td><tt>16:49.09</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>btw, I msg'd the url there because I can't msg
here and I don't know how public you want that info... I'll delete
it if you want</tt></td>
</tr>
<tr class="c3">
<td><tt>16:50.20</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Ah, nothing sensitive in there</tt></td>
</tr>
<tr class="c3">
<td><tt>16:53.49</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>ok, thandler is the 'trap handler' and
shandler is the 'syscall handler', in the mach kernel (micro, so
it's handled via messages and 'servers', not function
calls)</tt></td>
</tr>
<tr class="c3">
<td><tt>16:54.33</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Trap handler sounds like handling of page
faults when running out of ram</tt></td>
</tr>
<tr class="c3">
<td><tt>16:54.53</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Syscall handler... Growing the heap size? 25%
of the processing time? Gez.</tt></td>
</tr>
<tr class="c3">
<td><tt>17:06.47</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hrm, dude, I have 2g of ram and I'm only using
like 200m</tt></td>
</tr>
<tr class="c3">
<td><tt>17:06.53</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>and I never touched swap</tt></td>
</tr>
<tr class="c3">
<td><tt>17:07.13</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>now the trap might be cache line related or
something else *shrug* and itt might be system wide, not just
applied to your application</tt></td>
</tr>
<tr class="c3">
<td><tt>17:09.17</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I just ran a program to allocate a gig in 1m
chunks and write crap to every page... almost no system time
consumed in that (16s user, 3s sys)</tt></td>
</tr>
<tr class="c3">
<td><tt>17:09.35</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>no slowdown in it, so no swap hit</tt></td>
</tr>
<tr class="c3">
<td><tt>17:10.23</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>about 1.5g I start seeing swap hits</tt></td>
</tr>
<tr class="c3">
<td><tt>17:11.28</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Right. I could be mistaken, but the trap
handler handles page faults and I don't see what else could be
causing faults..</tt></td>
</tr>
<tr class="c3">
<td><tt>17:13.59</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>page fault is just one kind of trap</tt></td>
</tr>
<tr class="c3">
<td><tt>17:16.26</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>ok, in the midst of the ugly, the syscall
handler is 54% and the trap handler is 21.5%,</tt></td>
</tr>
<tr class="c3">
<td><tt>17:16.40</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>the trap that consumes most time looks to be
"ml_set_interrupts_enabled"</tt></td>
</tr>
<tr class="c3">
<td><tt>17:17.07</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>only 1% of the time is vm_fault</tt></td>
</tr>
<tr class="c3">
<td><tt>17:17.28</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I can't think of any other syscall being made
but malloc() and friends</tt></td>
</tr>
<tr class="c3">
<td><tt>17:17.43</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>"isync" is the big trap abuse</tt></td>
</tr>
<tr class="c3">
<td><tt>17:17.57</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>context switches force traps and shit,
too</tt></td>
</tr>
<tr class="c3">
<td><tt>17:19.21</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>ok, isync stops new ops from entering the
pipeline and waits until the pipeline is empty, "This instruction
is context synchronizing"</tt></td>
</tr>
<tr class="c3">
<td><tt>17:19.39</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>for OS memory management tasks, like changes
in the mmu</tt></td>
</tr>
<tr class="c3">
<td><tt>17:23.22</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>"large_and_huge_malloc" might be related, in
mmAlloc under sampleAddTri</tt></td>
</tr>
<tr class="c3">
<td><tt>17:24.46</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>20-40k is "large and huge" ?</tt></td>
</tr>
<tr class="c3">
<td><tt>17:25.15</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>bigger than a page *shrug* I d'no, heh, I'm
looking through this stuff more or less lost...</tt></td>
</tr>
<tr class="c3">
<td><tt>17:25.18</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>&lt;-- doesn't know ppc asm :)</tt></td>
</tr>
<tr class="c3">
<td><tt>17:25.26</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>#define SAMPLE_TRIANGLES_PER_LIST (4096) 
could be set to 200k or something *shrug*, to have fewer
calls</tt></td>
</tr>
<tr class="c3">
<td><tt>17:51.38</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Erik, could one of OSX's "security feature" be
to zero malloc() chunks or something? I'm running out of
hypotheses</tt></td>
</tr>
<tr class="c3">
<td><tt>17:52.38</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>might be *shrug* I d'no</tt></td>
</tr>
<tr class="c3">
<td><tt>17:55.12</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>"The default malloc on OS X causes a large
performance degradation relative to the default mallocs on Linux
and Solaris."</tt></td>
</tr>
<tr class="c3">
<td><tt>17:55.16</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Gah.</tt></td>
</tr>
<tr class="c3">
<td><tt>17:56.42</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>50% slower, nothing of the scale we saw
here</tt></td>
</tr>
<tr class="c3">
<td><tt>18:07.06</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>interesting, a significant portion of time
looks like it's attribtued to handling l2 cache misses</tt></td>
</tr>
<tr class="c3">
<td><tt>18:09.45</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>ahhhhhhhhh</tt></td>
</tr>
<tr class="c3">
<td><tt>18:10.05</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>mmAlloc() cooks up time in a kernel function
called "Zero Fill"</tt></td>
</tr>
<tr class="c3">
<td><tt>18:10.15</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>AHH!!</tt></td>
</tr>
<tr class="c3">
<td><tt>18:10.26</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>which'd explain cache thrashing</tt></td>
</tr>
<tr class="c3">
<td><tt>18:10.35</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>_That_ is the reason, I'm allocating a whole
bunch and freeing, sometimes without even using the
chunks</tt></td>
</tr>
<tr class="c3">
<td><tt>18:10.59</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>learn somethin' new every day</tt></td>
</tr>
<tr class="c3">
<td><tt>18:11.22</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Can you fix that?</tt></td>
</tr>
<tr class="c3">
<td><tt>18:11.30</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Can you make malloc() behave in a sane
manner?</tt></td>
</tr>
<tr class="c3">
<td><tt>18:12.32</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>googling for that now... and 'sane' is a
phrase that can be argued against... :D quit abusing malloc?
*duck*</tt></td>
</tr>
<tr class="c3">
<td><tt>18:12.37</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt><a href=
"http://lists.apple.com/archives/Darwin-development/2003/Apr/msg00217.html">
http://lists.apple.com/archives/Darwin-development/2003/Apr/msg00217.html</a>
mentions some</tt></td>
</tr>
<tr class="c3">
<td><tt>18:12.46</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Maybe there are multiple memory managers on
OSX, as there are multiple threading libraries on fbsd ( and the
default one is horrible too )</tt></td>
</tr>
<tr class="c3">
<td><tt>18:13.17</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Why would an OS ever memset() malloc'ed
chunks? I can do that myself I need it, that's absurd</tt></td>
</tr>
<tr class="c3">
<td><tt>18:13.28</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>if* I need it</tt></td>
</tr>
<tr class="c3">
<td><tt>18:13.49</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The segfault mentionned earlier was fixed
too</tt></td>
</tr>
<tr class="c3">
<td><tt>18:13.56</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt><a href=
"http://lists.apple.com/archives/Darwin-development/2003/Apr/msg00210.html">
http://lists.apple.com/archives/Darwin-development/2003/Apr/msg00210.html</a>
  answers that, heh</tt></td>
</tr>
<tr class="c3">
<td><tt>18:14.01</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>security mechanism</tt></td>
</tr>
<tr class="c3">
<td><tt>18:14.11</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Absurd.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:16.01</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt><a href=
"http://developer.apple.com/tools/performance/optimizingwithsystemtrace.html">
http://developer.apple.com/tools/performance/optimizingwithsystemtrace.html</a>
  and search for "zero-fill"</tt></td>
</tr>
<tr class="c3">
<td><tt>18:17.25</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>So I have to write my own full-featured memory
manager because the OSX manager is too incompetent to care about
performance</tt></td>
</tr>
<tr class="c3">
<td><tt>18:17.48</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>well, the converse argument is that the linux
memory manager is too incompetent to care about security</tt></td>
</tr>
<tr class="c3">
<td><tt>18:17.52</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That also explains why even the m1a2 was
taking so long to prep on your laptops, it's supposed to be a few
seconds</tt></td>
</tr>
<tr class="c3">
<td><tt>18:18.26</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>If a process puts sensitive stuff in RAM, it's
the duty of _that_ process to mlock() the memory and clear it
accordingly</tt></td>
</tr>
<tr class="c3">
<td><tt>18:18.44</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Don't slow down the whole OS for a few chunks
of ram that might possibly contain something sensitive</tt></td>
</tr>
<tr class="c3">
<td><tt>18:19.09</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>heh</tt></td>
</tr>
<tr class="c3">
<td><tt>18:19.22</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>in the land of incompetent coders...
:)</tt></td>
</tr>
<tr class="c3">
<td><tt>18:19.32</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>mlock() and related functions exist for a good
reason</tt></td>
</tr>
<tr class="c3">
<td><tt>18:19.45</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>yes, as do calloc(), etc...</tt></td>
</tr>
<tr class="c3">
<td><tt>18:20.33</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Grah, this is so absurd</tt></td>
</tr>
<tr class="c3">
<td><tt>18:20.58</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>freebsd does the same thing,
apparently</tt></td>
</tr>
<tr class="c3">
<td><tt>18:21.04</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt><a href=
"http://kerneltrap.org/node/72">http://kerneltrap.org/node/72</a></tt></td>
</tr>
<tr class="c3">
<td><tt>18:22.55</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Seriously, this makes no sense at all. There
are POSIX functions to take care of storing sensitive information
in RAM</tt></td>
</tr>
<tr class="c3">
<td><tt>18:23.16</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>... and if people USED them, then os's
wouldn't have to step up and cover</tt></td>
</tr>
<tr class="c3">
<td><tt>18:24.06</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>This is a _very_ bad fix.  Fix the software,
don't hack a slow and patchy solution in the OS</tt></td>
</tr>
<tr class="c3">
<td><tt>18:24.46</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>heh, and it seems to be a hot issue in linux
kernel development right now</tt></td>
</tr>
<tr class="c3">
<td><tt>18:25.23</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(and if the software is designed to break the
os? malicious code exists :/ )</tt></td>
</tr>
<tr class="c3">
<td><tt>18:26.08</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Okay. Do you have a full-featured and complete
memory manager in BRL-CAD already?</tt></td>
</tr>
<tr class="c3">
<td><tt>18:26.22</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt><a href=
"http://lists.apple.com/archives/darwin-development/2003/Apr/msg00227.html">
http://lists.apple.com/archives/darwin-development/2003/Apr/msg00227.html</a>
  has more</tt></td>
</tr>
<tr class="c3">
<td><tt>18:26.29</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>yeah, in libbu</tt></td>
</tr>
<tr class="c3">
<td><tt>18:26.31</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>um</tt></td>
</tr>
<tr class="c3">
<td><tt>18:26.52</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>but the behavior of "lots of allocs and
deallocs" is gonna be slow if it's passed to the os...</tt></td>
</tr>
<tr class="c3">
<td><tt>18:27.02</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Seriously, the OS could bzero() pages as the
heap grows, but OSX seems to clear even reused pages ; malloc'ing
without expanding the heap</tt></td>
</tr>
<tr class="c3">
<td><tt>18:27.30</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Normally, malloc() only reaches the OS if the
heap has to be extended. Otherwise, it stays entirely in user
space</tt></td>
</tr>
<tr class="c3">
<td><tt>18:27.34</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>On a sane and decent OS anyway</tt></td>
</tr>
<tr class="c3">
<td><tt>18:28.02</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>erm, ... vm and wm are different,
dude</tt></td>
</tr>
<tr class="c3">
<td><tt>18:29.13</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(heh, and this is exactly where compacting
gc's shine)</tt></td>
</tr>
<tr class="c3">
<td><tt>18:29.45</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Checking libbu, I only saw red-black tree
stuff there last time</tt></td>
</tr>
<tr class="c3">
<td><tt>18:30.34</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I'm pretty sure the libbu memory management is
just portable passthrough stuff, though</tt></td>
</tr>
<tr class="c3">
<td><tt>18:31.36</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>stupid headache *grr*</tt></td>
</tr>
<tr class="c3">
<td><tt>18:32.00</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I really don't feel like writing a memory
manager to handle broken malloc() implementations, but if I
must..</tt></td>
</tr>
<tr class="c3">
<td><tt>18:32.17</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>&lt;-- thinks it's less broken than linux's
:(</tt></td>
</tr>
<tr class="c3">
<td><tt>18:33.03</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Surely you agree that if software deals with
sensitive information, there are robust and _efficient_ mechanisms
to deal with this, instead of having every malloc() call being
zero'ed?</tt></td>
</tr>
<tr class="c3">
<td><tt>18:33.28</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>given the quality of 95% of coders writing
'real' applications, no. I don't.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:33.34</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>malloc()'ed memory is not supposed to be
cleared, it's supposed to be fast</tt></td>
</tr>
<tr class="c3">
<td><tt>18:34.07</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hm, I've never thought of malloc as a fast
operation *shrug* if you want fast, allocate a big honkin' heap and
do it yourself in that...</tt></td>
</tr>
<tr class="c3">
<td><tt>18:34.33</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Clearing the new pages as the heap grows would
have made a certain sense, but for every malloc call, this is
highly absurd</tt></td>
</tr>
<tr class="c3">
<td><tt>18:34.48</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>...</tt></td>
</tr>
<tr class="c3">
<td><tt>18:35.00</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>you cannot make that statement because of how
mmu's work.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:35.21</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>you can free 4k, and then "immediately" alloc
4k, and you are not guaranteed that you got the same 4k
back</tt></td>
</tr>
<tr class="c3">
<td><tt>18:35.33</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>you coudl've gotten one of my pages, or a
completely different page altogether</tt></td>
</tr>
<tr class="c3">
<td><tt>18:35.50</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Of course not, but it's likely to be within
the heap for the process address space</tt></td>
</tr>
<tr class="c3">
<td><tt>18:36.11</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>... for the process address space, yes... but
not the wired address space</tt></td>
</tr>
<tr class="c3">
<td><tt>18:36.33</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>physical memory doesn't line up to process
memory, that's what the mmu does...</tt></td>
</tr>
<tr class="c3">
<td><tt>18:36.39</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The heap never shrinks, the OS doesn't know
that the page is now unused</tt></td>
</tr>
<tr class="c3">
<td><tt>18:36.59</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>erm, which heap? heh</tt></td>
</tr>
<tr class="c3">
<td><tt>18:37.27</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The heap of the process ; the memory manager
is likely to reuse that page and you'll get what you had previously
stored there, without ever making a syscall</tt></td>
</tr>
<tr class="c3">
<td><tt>18:37.28</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>free() is to mark a heap as unused so it can
be culled...</tt></td>
</tr>
<tr class="c3">
<td><tt>18:37.43</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>and it disassociates it from the wired
page</tt></td>
</tr>
<tr class="c3">
<td><tt>18:37.45</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>So the heap can shrink on OSX? It never does
on Linux</tt></td>
</tr>
<tr class="c3">
<td><tt>18:38.56</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That seems to be a logical explanation as to
why every malloc() call is zero'ed</tt></td>
</tr>
<tr class="c3">
<td><tt>18:40.27</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>the process heap should be able to shrink on
every os :/</tt></td>
</tr>
<tr class="c3">
<td><tt>18:40.46</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>now the memory address of new allocations is
up in the air, but *shrug*</tt></td>
</tr>
<tr class="c3">
<td><tt>18:42.04</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>You can't shrink the heap on Linux. If it
grows high and shrink, unused high pages will eventually be put on
swap to make room for other processes, and just forgotten</tt></td>
</tr>
<tr class="c3">
<td><tt>18:42.15</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That design has its flaws too ( the swapping
)</tt></td>
</tr>
<tr>
<td><tt>18:42.17</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad cadguy
(n=butler@bz.bzflag.bz)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>18:42.26</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>heh, and eventually oom</tt></td>
</tr>
<tr class="c3">
<td><tt>18:42.56</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>Yo!  How is everyone?</tt></td>
</tr>
<tr class="c3">
<td><tt>18:43.00</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(might be why I've seen ugly oom's on linux,
it's malloc is broken... O:-) )</tt></td>
</tr>
<tr class="c3">
<td><tt>18:43.18</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Good afternoon Lee</tt></td>
</tr>
<tr class="c3">
<td><tt>18:43.35</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>email is sent, lee... subj "Sql"</tt></td>
</tr>
<tr class="c3">
<td><tt>18:43.36</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>BSD's malloc() seems less broken than OSX
still, it clears new pages but not the content of every malloc()
call</tt></td>
</tr>
<tr class="c3">
<td><tt>18:43.44</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>Howdy Maloeran</tt></td>
</tr>
<tr class="c3">
<td><tt>18:44.06</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Just having a long debate with Erik about why
the raytracer's prep is so terribly slow on OSX</tt></td>
</tr>
<tr class="c3">
<td><tt>18:44.09</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>osX only zerofills when the freshly allocated
page is touched, as far as I can tell</tt></td>
</tr>
<tr class="c3">
<td><tt>18:45.26</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Now reading libbu's memory manager, I suppose
that's the solution to work around inefficient malloc
implementations</tt></td>
</tr>
<tr class="c3">
<td><tt>18:45.27</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>Hmm.  How many pages are we allocating? 
Lots?</tt></td>
</tr>
<tr class="c3">
<td><tt>18:45.40</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Lots of pages, which are often just unused and
freed</tt></td>
</tr>
<tr class="c3">
<td><tt>18:45.57</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>malloc() is quite fast on Linux as pages are
never cleared</tt></td>
</tr>
<tr class="c3">
<td><tt>18:45.58</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>Yes, that's a notorious performance
killer.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:46.09</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>That's a security issue.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:46.45</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>When dealing with sensitive information,
processes can mlock() the memory, there are POSIX functions to take
care of that</tt></td>
</tr>
<tr class="c3">
<td><tt>18:47.25</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>But as Erik argued, a dirty and inefficient
fix at the OS level seems to be required due to the amount of bad
software out there... *shakes head*</tt></td>
</tr>
<tr class="c3">
<td><tt>18:47.42</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>The usual technique is to keep a buffer pool
if you want to alloc/free a lot to keep the code easy.  Then
allocate through your own buffer pool.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:48.31</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>*nod* allocate a slew of pages, keep 'free'
and 'used' linked lists, when one is freed or allocated, just
change which list it lives in</tt></td>
</tr>
<tr class="c3">
<td><tt>18:48.39</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>Yea.  Lots of lame code mucking around with
priviledges.  Remember mlock() didn't appear until
4.4BSD.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:48.41</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Right. I'm checking libbu, but I won't hide
that I'm used to deal with an efficient malloc
implementation</tt></td>
</tr>
<tr class="c3">
<td><tt>18:49.13</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>if you allocate with nothing in the free list,
free more... if you're worried about memory consumption, free()
some out of the free list when it reaches a threshhold</tt></td>
</tr>
<tr class="c3">
<td><tt>18:49.28</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>s/efficient/insecure/ :)</tt></td>
</tr>
<tr class="c3">
<td><tt>18:49.51</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Yes yes, I got that to deal with many small
chunks. I haven't got a full memory manager to deal with chunks of
all sizes and shapes</tt></td>
</tr>
<tr class="c3">
<td><tt>18:49.52</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>No reason to hide.  Just be aware that there
are space/time/security tradeoffs that different OS's
make.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:50.03</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>my bike goes 20kph and stays together, yours
goes 30 and kicks the wheels off every 50km</tt></td>
</tr>
<tr class="c3">
<td><tt>18:50.05</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>:D</tt></td>
</tr>
<tr class="c3">
<td><tt>18:50.52</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>:) Eh well, time to write a memory manager
then!</tt></td>
</tr>
<tr class="c3">
<td><tt>18:51.24</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>&lt;-- thought that's what mm was supposed to
be o.O :)</tt></td>
</tr>
<tr class="c3">
<td><tt>18:51.56</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>It's not a full-blown memory manager, it has
efficient handling of packed tiny chunks, balanced trees,
etc.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:52.47</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>since Linux's malloc() always performed
decently for management of medium to large sized chunks</tt></td>
</tr>
<tr class="c3">
<td><tt>18:53.26</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>In general, any time you can avoid a system
call, it is worth doing.</tt></td>
</tr>
<tr class="c3">
<td><tt>18:54.46</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>On Linux, free() never shrinks the heap, so
malloc() will always remain in user-space unless the heap has to
grow. I realize it's quite different on OSX</tt></td>
</tr>
<tr class="c3">
<td><tt>18:55.36</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>And different on solaris and other
Unix's</tt></td>
</tr>
<tr class="c3">
<td><tt>19:07.54</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That model really is a challenge for any
acceleration structure, the planned second 'prep' pass should
improve things a bit... but mostly, ray bundles will</tt></td>
</tr>
<tr class="c3">
<td><tt>19:08.05</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That and threads</tt></td>
</tr>
<tr class="c3">
<td><tt>19:09.48</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>oohhhhh, rfTraceRays() calls malloc,
too</tt></td>
</tr>
<tr class="c3">
<td><tt>19:11.58</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Only if there are no already allocated 'job'
struct in the list, nothing to worry about there</tt></td>
</tr>
<tr class="c3">
<td><tt>19:15.13</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>that dstdir=mathPlanePoint() line (634) is a
major contributor to L2 cache misses (27.5%)</tt></td>
</tr>
<tr class="c3">
<td><tt>19:15.39</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>second being line 582
"if(src[linkflags&amp;RF_NODE_AXIS_MASK]&lt;NODE(root)-&gt;plane)"
at 6.6%</tt></td>
</tr>
<tr class="c3">
<td><tt>19:16.56</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The prototype had prefetch instructions for
caching triangles before the actual tests, that should
help</tt></td>
</tr>
<tr class="c3">
<td><tt>19:17.19</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>memory bandwidth looks like, um, around
200-300 MB/s read and 20-30MB/s write</tt></td>
</tr>
<tr class="c3">
<td><tt>19:17.32</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>You know, I really like your profiler
:)</tt></td>
</tr>
<tr class="c3">
<td><tt>19:17.50</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>heh, me too, this thing is gnarly</tt></td>
</tr>
<tr class="c3">
<td><tt>19:18.06</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>You really should try to pick it up.</tt></td>
</tr>
<tr class="c3">
<td><tt>19:18.39</tt></td>
<td><span class="c7"><tt>cadguy</tt></span></td>
<td width="100%"><tt>Want me to talk with Mark?</tt></td>
</tr>
<tr class="c3">
<td><tt>19:19.30</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Thanks, just give me 33 hours to receive my
first real pay check from Survice assuming the 30 days delay after
the end of the month is respected</tt></td>
</tr>
<tr class="c3">
<td><tt>19:20.19</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>you got your travel expenses and per diem all
sorted out, correct?</tt></td>
</tr>
<tr class="c3">
<td><tt>19:21.07</tt></td>
<td><span class="c4"><tt>CIA-9</tt></span></td>
<td width="100%"><tt>BRL-CAD: 03lbutler * 10brlcad/sh/gforge.sh:
script for querying a gforge site</tt></td>
</tr>
<tr class="c3">
<td><tt>19:21.34</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I had no per diem expenses in August, but
sure</tt></td>
</tr>
<tr>
<td><tt>19:23.24</tt></td>
<td colspan="2"><tt><span class="c1">*** join/#brlcad IriX64
(n=IriX64@bas3-sudbury98-1168052970.dsl.bell.ca)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>19:23.38</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>dude, if you ever do work related travel, the
employer should set everything up and take care of all the
(reasonable) expenses...</tt></td>
</tr>
<tr class="c3">
<td><tt>19:24.34</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it's chump change to them, a no brainer
investment...</tt></td>
</tr>
<tr class="c3">
<td><tt>19:27.16</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Ah don't worry, I'll be quite fine. The 30
days delay for a monthly pay is just a bit annoying, after 2-3
months of unpaid vacation anyway ;)</tt></td>
</tr>
<tr class="c3">
<td><tt>19:27.41</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>rtiBatchNsCallback() is your flat shadow-less
shader?</tt></td>
</tr>
<tr class="c3">
<td><tt>19:27.53</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Somewhat, yes</tt></td>
</tr>
<tr class="c3">
<td><tt>20:57.14</tt></td>
<td><span class="c4"><tt>CIA-9</tt></span></td>
<td width="100%"><tt>BRL-CAD: 03lbutler * 10brlcad/sh/gforge.sh:
make script adaptable to host</tt></td>
</tr>
<tr class="c3">
<td><tt>21:13.00</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Erik, before I write a bunch of code, do you
have Hoard handy to see if the memory manager does a better
job?</tt></td>
</tr>
<tr class="c3">
<td><tt>21:13.25</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>It might clear pages the BSD way even on
OSX</tt></td>
</tr>
<tr class="c3">
<td><tt>22:43.50</tt></td>
<td><span class="c5"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hoard? nope</tt></td>
</tr>
<tr class="c3">
<td><tt>23:16.54</tt></td>
<td><span class="c2"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Oh well. Everything but sectors and steps are
now allocated by sliced blocks, these chunks of variable size will
have their own personal little memory manager</tt></td>
</tr>
</table>
<br />
Generated by irclog2html.pl by <a href=
"mailto:jdub@NOSPAMaphid.net">Jeff Waugh</a> - find it at <a href=
"http://freshmeat.net/appindex/2000/03/28/954251322.html">freshmeat.net</a>!
Modified by <a href="http://www.Rikers.org">Tim Riker</a> to work
with <a href="http://blootbot.sourceforge.net/">blootbot</a> logs,
split per channel, etc.
</body>
</html>
