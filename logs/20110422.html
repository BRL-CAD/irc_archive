<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.6.0" />
<title>IRC log for #brlcad on 20110422</title>
<meta name="generator" content="irclog2html.pl" />
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<style type="text/css">
/*<![CDATA[*/
 body {
  background-color: #FFFFFF;
  color: #000000;
 }
 span.c11 {color: #D9D972}
 span.c10 {color: #D06D6D}
 span.c9 {color: #000099}
 span.c8 {color: #6ED16E}
 span.c7 {color: #009900}
 span.c6 {color: #C36666}
 span.c5 {color: #CC00CC}
 span.c4 {color: #8C4A4A}
 tr.c3 {background-color: #EEEEEE}
 span.c2 {color: #854685}
 ins.c1 {display:inline-block;width:728px;height:90px}
/*]]>*/
</style>
</head>
<body>
<h1>IRC log for #brlcad on 20110422</h1>
<script async="async" src=
"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Default -->
<ins class="adsbygoogle c1" data-ad-client=
"ca-pub-1563266826402652" data-ad-slot="5026919875"></ins> 
<script>
<![CDATA[

(adsbygoogle = window.adsbygoogle || []).push({});
]]>
</script>
<form action="http://www.google.com" id="cse-search-box">
<div><input type="hidden" name="cx" value=
"partner-pub-1563266826402652:3301963896" /> <input type="hidden"
name="ie" value="UTF-8" /> <input type="text" name="q" size="55" />
<input type="submit" name="sa" value="Search" /></div>
</form>
<script type="text/javascript" src=
"http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<table cellspacing="3" cellpadding="2" border="0">
<tr class="c3">
<td><tt>00:01.27</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>gprof excels at function-level
analysis</tt></td>
</tr>
<tr class="c3">
<td><tt>00:01.42</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>growl... for whatever reason, that's not
working on the mac either</tt></td>
</tr>
<tr class="c3">
<td><tt>00:01.50</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>either in isolation or as part of the
build</tt></td>
</tr>
<tr class="c3">
<td><tt>00:01.58</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>to linux...</tt></td>
</tr>
<tr class="c3">
<td><tt>00:02.35</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>TODO: fix profiling option :)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:03.05</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>(presuming you're using gprof right)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:03.28</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>yep, but I'm assuming it's my mac's fault
until proven otherwise</tt></td>
</tr>
<tr class="c3">
<td><tt>00:04.26</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>unlikely, it's not like shark</tt></td>
</tr>
<tr class="c3">
<td><tt>00:04.55</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it's not cpu metrics, it injects code around
all your functions</tt></td>
</tr>
<tr class="c3">
<td><tt>00:05.14</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>so if gcc works, it should work</tt></td>
</tr>
<tr class="c3">
<td><tt>00:05.26</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>gprof works on inux</tt></td>
</tr>
<tr class="c3">
<td><tt>00:05.29</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>linux even</tt></td>
</tr>
<tr class="c3">
<td><tt>00:07.03</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ok, whatever works</tt></td>
</tr>
<tr class="c3">
<td><tt>00:09.25</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>must... fix... mac...</tt></td>
</tr>
<tr class="c3">
<td><tt>00:10.47</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>yeah, ok - my uvpoints.cpp file is wasting
most of its time with strings</tt></td>
</tr>
<tr class="c3">
<td><tt>00:10.53</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>no wonder</tt></td>
</tr>
<tr class="c3">
<td><tt>00:19.57</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>(fwiw, "using std namespace" is
evil)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:20.10</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>er, using namespace std;</tt></td>
</tr>
<tr class="c3">
<td><tt>00:20.22</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>I know -  it's just a test program, not
intended for production in its current form</tt></td>
</tr>
<tr class="c3">
<td><tt>00:20.31</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ah, interesting</tt></td>
</tr>
<tr class="c3">
<td><tt>00:20.52</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>scratchpad for experimenting with uv
coordinates, memory pools, etc. without the complexity of the
SurfaceTree</tt></td>
</tr>
<tr class="c3">
<td><tt>00:20.55</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>perhaps a less on references, pointers, and
std:: data types :)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.06</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>damn, can't type tonight</tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.15</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>lesson</tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.18</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt><span class="c5">winces - yeah, I'm quite sure
I'm using it all wrong</span></tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.29</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>you're passing std::string in and out of
functions</tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.41</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>that makes a copy of the string every function
call</tt></td>
</tr>
<tr class="c3">
<td><tt>00:21.47</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>and every return</tt></td>
</tr>
<tr class="c3">
<td><tt>00:22.00</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>malloc-style</tt></td>
</tr>
<tr class="c3">
<td><tt>00:22.29</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>you want to either pass around std::string*'s
or std::string&amp;'s depending on the use</tt></td>
</tr>
<tr class="c3">
<td><tt>00:22.53</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>depends who creates the string and how it's
used</tt></td>
</tr>
<tr class="c3">
<td><tt>00:23.37</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>safest is to pass a pointer, but best is
usually a ref .. but then you have to be more careful on how it's
accessed and stored</tt></td>
</tr>
<tr class="c3">
<td><tt>00:24.57</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt><span class="c5">nods - any good
tutorials?</span></tt></td>
</tr>
<tr class="c3">
<td><tt>00:25.08</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>e.g. UVKey::UVKey() is fine taking a
std::string newkey (so it'll make a copy on construction), but
UVKey::getKey() should return a std::string&amp;</tt></td>
</tr>
<tr class="c3">
<td><tt>00:31.52</tt></td>
<td><span class="c6"><tt>CIA-105</tt></span></td>
<td width="100%"><tt>BRL-CAD: 03starseeker * r44486
10/brlcad/trunk/src/librt/uvpoints.cpp: Try returning a
reference</tt></td>
</tr>
<tr class="c3">
<td><tt>00:31.55</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>brlcad: like that?</tt></td>
</tr>
<tr class="c3">
<td><tt>00:32.34</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>yeah, that's better</tt></td>
</tr>
<tr class="c3">
<td><tt>00:33.17</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>one thing to remember, that change now changes
the contract for UVKey -- it's no longer just a string, it's
UVKey's string</tt></td>
</tr>
<tr class="c3">
<td><tt>00:33.37</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt><span class="c5">nods - that was the idea
originally, actually</span></tt></td>
</tr>
<tr class="c3">
<td><tt>00:33.43</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>so if you delete UVKey, any references to a
std::string from getKey() would be dangling references
(invalid)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:33.47</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>yow, string comparison is brutal</tt></td>
</tr>
<tr class="c3">
<td><tt>00:35.26</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>yeah, that was my next question .. what's up
with string keys??</tt></td>
</tr>
<tr class="c3">
<td><tt>00:35.33</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>numeric ftw</tt></td>
</tr>
<tr class="c3">
<td><tt>00:35.41</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>they're UV coordinates</tt></td>
</tr>
<tr class="c3">
<td><tt>00:36.40</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>so?</tt></td>
</tr>
<tr class="c3">
<td><tt>00:36.50</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>I don't recall the original motivator - I
think it was to make it easier to mash together two pairs into one
unique descriptive string</tt></td>
</tr>
<tr class="c3">
<td><tt>00:36.52</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>yeah, AppendKeys() .. nfg</tt></td>
</tr>
<tr class="c3">
<td><tt>00:37.25</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ints_to_key looks like some sort of
string-based hash</tt></td>
</tr>
<tr class="c3">
<td><tt>00:37.51</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>just store them into a u,v array, O(1)
lookups</tt></td>
</tr>
<tr class="c3">
<td><tt>00:38.01</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>ah, right - 0100 and 0001 don't convert to
different integers</tt></td>
</tr>
<tr class="c3">
<td><tt>00:38.34</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>and those strings are the keys for a minimal
perfect hash</tt></td>
</tr>
<tr class="c3">
<td><tt>00:39.01</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>perfectly inefficient maybe :)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:39.07</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>probably I should stash them as numbers and
only build the strings when I need to</tt></td>
</tr>
<tr class="c3">
<td><tt>00:39.57</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>the original effort there was to find unique
identifiers for all the UV points that might get evaluated into
3-space during a subdivision of depth N</tt></td>
</tr>
<tr class="c3">
<td><tt>00:40.15</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>either way, even as a perfect hash, shouldn't
have a sprintf() call in there for generating a hash (heck,
shouldn't need to manually hash yourself anyways)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:40.17</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>because there are a lot of shared points, I
wanted a good way to avoid duplicate evaluations</tt></td>
</tr>
<tr class="c3">
<td><tt>00:41.13</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the std:: container hashing is pretty frickin
good</tt></td>
</tr>
<tr class="c3">
<td><tt>00:41.40</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>the simplest way to avoid duplicates was to
have a way for any subdivision, at any depth up until the maximum
depth, be able to look up a given UV coordinate to see if it had
been evaluated</tt></td>
</tr>
<tr class="c3">
<td><tt>00:42.32</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>you probably want a std::map</tt></td>
</tr>
<tr class="c3">
<td><tt>00:43.09</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>heck, maybe even a simple std::map&lt;u,
std::map&lt;v, value&gt; &gt;</tt></td>
</tr>
<tr class="c3">
<td><tt>00:43.23</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>how fast are those lookups?</tt></td>
</tr>
<tr class="c3">
<td><tt>00:43.33</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>guaranteed to be at least logN iirc</tt></td>
</tr>
<tr class="c3">
<td><tt>00:43.57</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>in theory, if I understand correctly, a
minimal perfect hash is O(1)</tt></td>
</tr>
<tr class="c3">
<td><tt>00:44.50</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>and as a tree deepens, we can build up a LOT
of points and do a LOT of lookups</tt></td>
</tr>
<tr class="c3">
<td><tt>00:46.06</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>so a minimal perfect hash of a unique string
descriptor of the UV coordinates, which is possible because we know
the candidate sites that might be evaluated in advance, allows us
to generate such a hash up front</tt></td>
</tr>
<tr class="c3">
<td><tt>00:46.38</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>if it's O(1) lookup and O(insane) to generate
the hash, you've kinda missed the boat</tt></td>
</tr>
<tr class="c3">
<td><tt>00:46.56</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>that's still just the minimum
guarantee</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.02</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>except the hash only has to be generated at
compile time</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.13</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>you mean prep?</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.18</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>no, compile</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.22</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>source code compile</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.38</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>er, there's no such thing going on in your
code there now</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.43</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>right</tt></td>
</tr>
<tr class="c3">
<td><tt>00:47.56</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>because it was early days when I had to shift
to other stuff</tt></td>
</tr>
<tr class="c3">
<td><tt>00:48.14</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>but it DOES generate the keys.txt file, which
contains the full list of unique keys</tt></td>
</tr>
<tr class="c3">
<td><tt>00:48.31</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>if there is a limited set of hash sites, why
not just direct index into a set then?</tt></td>
</tr>
<tr class="c3">
<td><tt>00:49.25</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>all I know when I'm subdividing is the UV
coordinates of the point I'm at - I have to map that to some index
value</tt></td>
</tr>
<tr class="c3">
<td><tt>00:49.37</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i'd still try the std::map first -- dead
simple implementation, easy to maintain, and really good
performance behavior guarantees</tt></td>
</tr>
<tr class="c3">
<td><tt>00:50.42</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>so the idea sounds fine, but it shouldn't be
based on or involve strings</tt></td>
</tr>
<tr class="c3">
<td><tt>00:51.47</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>uh... the string is key for hashing -
apparently hashing numbers usually doesn't work out well</tt></td>
</tr>
<tr class="c3">
<td><tt>00:52.11</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>my problem is I'm storing the info as a
string, which is wrong</tt></td>
</tr>
<tr class="c3">
<td><tt>00:52.12</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt><a href=
"http://www.sgi.com/tech/stl/hash_set.html">http://www.sgi.com/tech/stl/hash_set.html</a></tt></td>
</tr>
<tr class="c3">
<td><tt>00:52.42</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>again, configurable key type, even
configurable hash function</tt></td>
</tr>
<tr class="c3">
<td><tt>00:53.26</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>a hash set of hash maps perhaps for u,v to
value mapping</tt></td>
</tr>
<tr class="c3">
<td><tt>00:53.29</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt><a href=
"http://www.sgi.com/tech/stl/hash_map.html">http://www.sgi.com/tech/stl/hash_map.html</a></tt></td>
</tr>
<tr class="c3">
<td><tt>00:53.43</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>or hash_map of hash_maps</tt></td>
</tr>
<tr class="c3">
<td><tt>00:59.07</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the tradeoff with a std::map&lt;&gt; is that
std::hash_map&lt;&gt; will be faster (O(1) on average O(N) worst
case even with perfect hashing, have to account for collisions) but
it's not in any particular order if you need to iterate or
search</tt></td>
</tr>
<tr class="c3">
<td><tt>00:59.48</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>so find *this* UV is fast.. finding your
closest neighbor will be relatively expensive</tt></td>
</tr>
<tr class="c3">
<td><tt>01:00.25</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt><span class="c5">nods - so far there hasn't
been a need for nearest UV neighbor (famous last
words...)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>01:00.56</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>brlcad: let me see if I can take strings out
of what I'm doing now, at least up until keys.txt is
generated</tt></td>
</tr>
<tr class="c3">
<td><tt>01:01.04</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>that works in the right direction
regardless</tt></td>
</tr>
<tr class="c3">
<td><tt>01:01.52</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>once I'm doing that right, we can tangle with
the various hashing/mapping options</tt></td>
</tr>
<tr class="c3">
<td><tt>01:08.04</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>the minimal perfect hash appeals to me because
with this situation we don't NEED to have any collisions, but I
suppose I could be full of... err... converted dog food
too</tt></td>
</tr>
<tr>
<td><tt>01:14.28</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad KimK
(~Kim__@wlnt-02-246.dsl.netins.net)</span></tt></td>
</tr>
<tr>
<td><tt>02:31.04</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad IriX64
(~kvirc@bas2-sudbury98-1128565712.dsl.bell.ca)</span></tt></td>
</tr>
<tr>
<td><tt>03:22.05</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad juanman
(~quassel@unaffiliated/juanman)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>04:29.39</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>brlcad wins - will investigate stl map
tomorrow, then look into hash_map if that's not enough</tt></td>
</tr>
<tr class="c3">
<td><tt>04:29.55</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt><span class="c5">braces for another C++
learning curve</span></tt></td>
</tr>
<tr class="c3">
<td><tt>05:06.15</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it's important enough to warrant a simple
performance comparison</tt></td>
</tr>
<tr class="c3">
<td><tt>06:14.42</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>starseeker: here's a code snippet I just
whipped up for you to play with</tt></td>
</tr>
<tr class="c3">
<td><tt>06:15.35</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>shows how to use map, hash map, and shows the
comparative performance of each</tt></td>
</tr>
<tr class="c3">
<td><tt>06:41.24</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt><a href=
"http://brlcad.org/tmp/hasher.cxx">http://brlcad.org/tmp/hasher.cxx</a></tt></td>
</tr>
<tr class="c3">
<td><tt>06:42.42</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>just for kicks, I stubbed in some code sort of
showing worst case and best case perfect hashing .. though the
devil is truly in the details for all of them since a simple
datatype change or iteration change can completely skew the
comparison</tt></td>
</tr>
<tr class="c3">
<td><tt>06:44.12</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>only played two use-case scenarios, setting
and reading .. not iterating over all, nearest neighbor, deletions,
etc</tt></td>
</tr>
<tr class="c3">
<td><tt>06:45.30</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>also using the non-bounds-checked [] operator
instead of insert(), find(), and other functions</tt></td>
</tr>
<tr class="c3">
<td><tt>06:46.55</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>I'd suggest looking at a real worst case
trace, see how many insertions/lookups/deletions and what the tree
looks like -- shallowest, average, deepest</tt></td>
</tr>
<tr class="c3">
<td><tt>06:47.10</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>then mapping that into a test program
simulating the same behavior</tt></td>
</tr>
<tr class="c3">
<td><tt>06:50.51</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>should hopefully be a little more clear
how/why I think map or unordered_map will probably be more than
"good enough" given how much simpler they are to run with .. and if
not, looking into exactly why</tt></td>
</tr>
<tr>
<td><tt>07:33.21</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad Stattrav
(~Stattrav@117.202.22.183)</span></tt></td>
</tr>
<tr>
<td><tt>07:33.21</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad Stattrav
(~Stattrav@unaffiliated/stattrav)</span></tt></td>
</tr>
<tr>
<td><tt>08:10.31</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad crazy_imp
(~mj@a89-182-215-216.net-htp.de)</span></tt></td>
</tr>
<tr>
<td><tt>08:28.56</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad merzo
(~merzo@193.254.217.44)</span></tt></td>
</tr>
<tr>
<td><tt>08:30.38</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad b0ef
(~b0ef@226.27.202.84.customer.cdi.no)</span></tt></td>
</tr>
<tr>
<td><tt>09:38.38</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad KimK
(~Kim__@wlnt-02-246.dsl.netins.net)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>11:35.09</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>*readreadread* obsessing over a perfect hash
may be self defeating... also; O() is just one of the bits to
consider, there are 5 categories of asymptotic notation. qsort is a
poor performer on O(), but awesome in real life (omega is tight, k
is low, etc)</tt></td>
</tr>
<tr class="c3">
<td><tt>11:40.48</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hm, no system hash funcs in your demo, brlcad?
md5? sha1? :)</tt></td>
</tr>
<tr class="c3">
<td><tt>12:45.34</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>brlcad: thanks for the demo - that will be a
big help</tt></td>
</tr>
<tr class="c3">
<td><tt>12:48.28</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>hmm... u+v won't work, isn't unique 0 + 1 = 1
+ 0... probably need something like u * (some power of 10) +
v</tt></td>
</tr>
<tr class="c3">
<td><tt>12:48.52</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>that's a detail though</tt></td>
</tr>
<tr class="c3">
<td><tt>12:49.20</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt><span class="c5">rummages around for some
energy and gets moving</span></tt></td>
</tr>
<tr class="c3">
<td><tt>13:13.00</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>collisions may be acceptable... ergo;
quadratic (<a href=
"http://en.wikipedia.org/wiki/Quadratic_probing)">http://en.wikipedia.org/wiki/Quadratic_probing)</a>
or chained (each hash bin is a linked list)</tt></td>
</tr>
<tr>
<td><tt>13:17.15</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad KimK
(~Kim__@wlnt-02-246.dsl.netins.net)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>13:33.11</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>starseeker: it'll "work" .. it's just a really
really bad hash :)</tt></td>
</tr>
<tr class="c3">
<td><tt>13:33.15</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>lots of collisions</tt></td>
</tr>
<tr class="c3">
<td><tt>13:33.31</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>more showing the full range of impact it can
have</tt></td>
</tr>
<tr class="c3">
<td><tt>13:34.06</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>with the right hash, you approach the best
case instant update time of an array but worst case can be an order
worse than a simple map</tt></td>
</tr>
<tr class="c3">
<td><tt>13:34.54</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>all the more motivation to just stick with the
algo that makes most sense</tt></td>
</tr>
<tr class="c3">
<td><tt>13:36.35</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the data is a simple mapping of uv keys to a
3dpoint, so the immediate thought that comes to mind is
std::map&lt;std::pair&lt;int, int&gt;, vect_t&gt;</tt></td>
</tr>
<tr class="c3">
<td><tt>13:37.56</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>(do not use ON_3dpoint .. it's got lots of
junk, you can set the vect_t direct on read:  vect_t v =
VINIT_ZERO; ON_3dpoint p = v; ON_3dpoint *pp = new
ON_3dpoint(v);</tt></td>
</tr>
<tr class="c3">
<td><tt>13:38.25</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>they added operator support for getting the
value from a double*</tt></td>
</tr>
<tr class="c3">
<td><tt>13:46.10</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>good exercise for the reader to attempt adding
std::map&lt;std::pair&lt;int, int&gt;, vect_t&gt; and using proper
std::map::iterator instead of using the [] operator .. you'll get a
lot of insight</tt></td>
</tr>
<tr class="c3">
<td><tt>13:57.11</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>then switch it to [] and compare :)</tt></td>
</tr>
<tr>
<td><tt>14:31.14</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad dli
(~dli@67.55.46.44)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>14:46.25</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>brlcad: the map is good if we need things like
nearest-neighbor?</tt></td>
</tr>
<tr class="c3">
<td><tt>14:48.17</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt><span class="c5">wonders if triangulation
might just want that information, even if we don't need it for
raytracing</span></tt></td>
</tr>
<tr class="c3">
<td><tt>15:25.06</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>r-tree is the shizzle for nearest
neighbor</tt></td>
</tr>
<tr>
<td><tt>15:25.12</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad Stattrav
(~Stattrav@117.202.18.42)</span></tt></td>
</tr>
<tr>
<td><tt>15:25.12</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad Stattrav
(~Stattrav@unaffiliated/stattrav)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>15:25.41</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>but data repacking should never take more than
nlgn</tt></td>
</tr>
<tr class="c3">
<td><tt>15:25.59</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>poor cats, still reeling from the bathing this
morning</tt></td>
</tr>
<tr class="c3">
<td><tt>15:43.01</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>``Erik: this should appeal to your bit-level
side - can I take a floating point value and map it to an int
simply?</tt></td>
</tr>
<tr class="c3">
<td><tt>15:43.38</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>std::map is slow with floats, but for storage
the important thing is to have an easy, unique identifer</tt></td>
</tr>
<tr class="c3">
<td><tt>15:44.15</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>if the UV floating point coordinates can be
mapped to integers...</tt></td>
</tr>
<tr class="c3">
<td><tt>15:45.30</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>I hadn't properly considered what wanting to
split first on the knot points implies - it pretty much trashes my
subdivision gridding coordinate scheme</tt></td>
</tr>
<tr class="c3">
<td><tt>15:46.34</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>might be able to get away with just being
aware of which leaves contain knots, but more general solution of
being able to pick any given UV point, subdivide using it, and
using the std::map or something like it all the while sounds
nice</tt></td>
</tr>
<tr>
<td><tt>15:53.03</tt></td>
<td colspan="2"><tt><span class="c9">*** part/#brlcad willdye
(~willdye@198.183.6.23)</span></tt></td>
</tr>
<tr>
<td><tt>16:27.29</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad juanman
(~quassel@unaffiliated/juanman)</span></tt></td>
</tr>
<tr>
<td><tt>17:35.13</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad Stattrav
(~Stattrav@117.202.18.42)</span></tt></td>
</tr>
<tr>
<td><tt>17:35.13</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad Stattrav
(~Stattrav@unaffiliated/stattrav)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>17:47.37</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>hmm... <a href=
"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">
http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm</a></tt></td>
</tr>
<tr class="c3">
<td><tt>18:45.43</tt></td>
<td><span class="c10"><tt>kanzure</tt></span></td>
<td width="100%"><tt>did commercial CAD packages ever take more
than a few seconds to do a boolean operation on two
solids?</tt></td>
</tr>
<tr class="c3">
<td><tt>19:08.49</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>kanzure: I doubt it...</tt></td>
</tr>
<tr class="c3">
<td><tt>19:12.44</tt></td>
<td><span class="c10"><tt>kanzure</tt></span></td>
<td width="100%"><tt>hrm. weird. i'm reading some papers from the
90s where these programmers are cheering because they can merge a
few meshes "IN ALMOST EIGHT SECONDS!!"</tt></td>
</tr>
<tr class="c3">
<td><tt>19:13.03</tt></td>
<td><span class="c10"><tt>kanzure</tt></span></td>
<td width="100%"><tt>on some sort of sgi onyx machine (200 mhz..
etc.)</tt></td>
</tr>
<tr class="c3">
<td><tt>19:17.49</tt></td>
<td><span class="c11"><tt>bhinesley</tt></span></td>
<td width="100%"><tt>I'm off to the beach for the weekend. Have a
good weekend, everyone.</tt></td>
</tr>
<tr>
<td><tt>19:25.24</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad juanman
(~quassel@unaffiliated/juanman)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>19:36.48</tt></td>
<td><span class="c10"><tt>kanzure</tt></span></td>
<td width="100%"><tt>wow "CATIA uses polyhedral approximations for
intersection and boundary computations"</tt></td>
</tr>
<tr>
<td><tt>19:38.36</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad juanman
(~quassel@unaffiliated/juanman)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>19:44.36</tt></td>
<td><span class="c10"><tt>kanzure</tt></span></td>
<td width="100%"><tt>"We then use the trapezoidation of the
trimming polygon (using Seidel's algorithm) to perform logarithmic
time point location queries.</tt></td>
</tr>
<tr class="c3">
<td><tt>19:44.39</tt></td>
<td><span class="c10"><tt>kanzure</tt></span></td>
<td width="100%"><tt>"However, the accuracy of this result depends
on the magnitude of errors introduced by approximating the high
degree trimming curve through the boundary of the Gaudl
invariants."</tt></td>
</tr>
<tr class="c3">
<td><tt>19:44.43</tt></td>
<td><span class="c10"><tt>kanzure</tt></span></td>
<td width="100%"><tt>ok i give up on this paper</tt></td>
</tr>
<tr class="c3">
<td><tt>19:45.42</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>kanzure: which paper?</tt></td>
</tr>
<tr class="c3">
<td><tt>19:45.53</tt></td>
<td><span class="c10"><tt>kanzure</tt></span></td>
<td width="100%"><tt>one of krishnan's</tt></td>
</tr>
<tr class="c3">
<td><tt>19:46.14</tt></td>
<td><span class="c10"><tt>kanzure</tt></span></td>
<td width="100%"><tt>i'll use his other one where he uses matrix
math for constructing the intersection curve</tt></td>
</tr>
<tr class="c3">
<td><tt>20:39.27</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>brlcad: looks like the pair iteration is
slightly slower, I'm assuming due to the make_pair overhead: 
<a href=
"http://brlcad.org/~starseeker/map_test.cxx">http://brlcad.org/~starseeker/map_test.cxx</a></tt></td>
</tr>
<tr class="c3">
<td><tt>20:43.37</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>I can't get the iterator to work thus
far</tt></td>
</tr>
<tr class="c3">
<td><tt>20:56.05</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>ah, there we go - I THINK that works...
anyway, if I do full assignment instead of using drand48 the count
returned seems to match up</tt></td>
</tr>
<tr class="c3">
<td><tt>21:00.53</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>hmm, interesting - iterator is faster if I
replace drand48 with i in the insertion loops</tt></td>
</tr>
<tr>
<td><tt>21:01.03</tt></td>
<td colspan="2"><tt><span class="c7">*** join/#brlcad juanman
(~quassel@unaffiliated/juanman)</span></tt></td>
</tr>
<tr class="c3">
<td><tt>22:26.36</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hm, you could always do floor() or
ceiling()... could also grab a bit mask ( ((uint320t)f) &gt;&gt;
16) )</tt></td>
</tr>
<tr class="c3">
<td><tt>22:26.52</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>s/0/_/</tt></td>
</tr>
<tr class="c3">
<td><tt>22:27.51</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>``Erik: actually, even the worst case floating
point performance may not be a showstopper - plus, it looks like to
get performance benefit the data type in question needs to be small
anyway</tt></td>
</tr>
<tr class="c3">
<td><tt>22:29.22</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt><span class="c5">suspects, based on
conversations concerning STL libraries, that they probably are
doing whatever the sanest thing is for floats under the
hood</span></tt></td>
</tr>
<tr class="c3">
<td><tt>22:30.25</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>the guys who did stl are pretty good... don't
try to outsmart them, the key is to not use their stuff
wrong...</tt></td>
</tr>
<tr class="c3">
<td><tt>22:31.06</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt><span class="c5">nods</span></tt></td>
</tr>
<tr class="c3">
<td><tt>22:31.24</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>at the moment, we assume a full fpu... I'm
sure BRL-CAD on my arm7 would suck arse</tt></td>
</tr>
<tr class="c3">
<td><tt>22:31.40</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>heh</tt></td>
</tr>
<tr class="c3">
<td><tt>22:32.02</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt><a href=
"http://brlcad.org/~erik/20110422/">http://brlcad.org/~erik/20110422/</a>
 they are not happy :)</tt></td>
</tr>
<tr class="c3">
<td><tt>22:32.31</tt></td>
<td><span class="c4"><tt>starseeker</tt></span></td>
<td width="100%"><tt>hehe</tt></td>
</tr>
<tr class="c3">
<td><tt>23:04.18</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>starseeker: excellent that you got the pair
working along with iterators</tt></td>
</tr>
<tr class="c3">
<td><tt>23:04.28</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>that was more the point than actual
performance</tt></td>
</tr>
<tr class="c3">
<td><tt>23:05.07</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>make_pair() is probably injecting a tiny
overhead, you'd probably just call the pair&lt;&gt; constructor
directly where you can set values by const reference instead of by
value</tt></td>
</tr>
<tr class="c3">
<td><tt>23:06.18</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the other thing you should try is printing the
pair values through the iterator</tt></td>
</tr>
<tr class="c3">
<td><tt>23:06.43</tt></td>
<td><span class="c2"><tt>brlcad</tt></span></td>
<td width="100%"><tt>instead of just incrementing counter, try to
use the iterator</tt></td>
</tr>
<tr class="c3">
<td><tt>23:22.45</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>if I groked correctly, iterator classes are
insanely efficient once invoked... a machine optimizable deref,
iirc</tt></td>
</tr>
<tr class="c3">
<td><tt>23:23.31</tt></td>
<td><span class="c8"><tt>``Erik</tt></span></td>
<td width="100%"><tt>same level of machine nerdiness as a ^= b ^= a
^= b</tt></td>
</tr>
</table>
<br />
Generated by irclog2html.pl Modified by <a href=
"http://Rikers.org">Tim Riker</a> to work with <a href=
"http://infobot.sourceforge.net/">infobot</a>.
</body>
</html>
