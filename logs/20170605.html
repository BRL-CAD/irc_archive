<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.6.0" />
<title>IRC log for #brlcad on 20170605</title>
<meta name="generator" content="irclog2html.pl" />
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<style type="text/css">
/*<![CDATA[*/
 body {
  background-color: #FFFFFF;
  color: #000000;
 }
 span.c10 {color: #D97272}
 span.c9 {color: #71D671}
 span.c8 {color: #D67070}
 span.c7 {color: #70D5D5}
 span.c6 {color: #CC00CC}
 span.c5 {color: #6F6FD4}
 tr.c4 {background-color: #EEEEEE}
 span.c3 {color: #6ED16E}
 span.c2 {color: #009900}
 ins.c1 {display:inline-block;width:728px;height:90px}
/*]]>*/
</style>
</head>
<body>
<h1>IRC log for #brlcad on 20170605</h1>
<script async="async" src=
"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Default -->
<ins class="adsbygoogle c1" data-ad-client=
"ca-pub-1563266826402652" data-ad-slot="5026919875"></ins> 
<script>
<![CDATA[

(adsbygoogle = window.adsbygoogle || []).push({});
]]>
</script>
<form action="http://www.google.com" id="cse-search-box">
<div><input type="hidden" name="cx" value=
"partner-pub-1563266826402652:3301963896" /> <input type="hidden"
name="ie" value="UTF-8" /> <input type="text" name="q" size="55" />
<input type="submit" name="sa" value="Search" /></div>
</form>
<script type="text/javascript" src=
"http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
<table cellspacing="3" cellpadding="2" border="0">
<tr>
<td><tt>00:13.13</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad
scqdzsqsugpfvsyk
(~armin@dslc-082-083-184-129.pools.arcor-ip.net)</span></tt></td>
</tr>
<tr>
<td><tt>00:21.08</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad infobot
(ibot@rikers.org)</span></tt></td>
</tr>
<tr>
<td><tt>00:21.08</tt></td>
<td colspan="2"><tt><span class="c2">*** topic/#brlcad is GSoC
students: if you have a question, ask and wait for an answer ...
responses may take minutes or hours. Ask and WAIT.
;)</span></tt></td>
</tr>
<tr>
<td><tt>01:06.38</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad teepee
(~teepee@unaffiliated/teepee)</span></tt></td>
</tr>
<tr>
<td><tt>01:10.25</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad DaRock
(~Thunderbi@mail.unitedinsong.com.au)</span></tt></td>
</tr>
<tr>
<td><tt>03:23.46</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>03:24.36</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>03:25.26</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>03:26.11</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>03:27.01</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>03:27.51</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>03:28.36</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>03:29.26</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>03:30.11</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>03:40.21</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad teepee_
(~teepee@unaffiliated/teepee)</span></tt></td>
</tr>
<tr>
<td><tt>06:50.13</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad
inxirwtrrrpwmydy
(~armin@dslc-082-083-184-129.pools.arcor-ip.net)</span></tt></td>
</tr>
<tr>
<td><tt>07:26.15</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad Caterpillar
(~caterpill@unaffiliated/caterpillar)</span></tt></td>
</tr>
<tr>
<td><tt>10:43.42</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad DaRock
(~Thunderbi@mail.unitedinsong.com.au)</span></tt></td>
</tr>
<tr>
<td><tt>13:08.07</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>13:28.21</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad yorik
(~yorik@2804:431:f721:94ee:290:f5ff:fedc:3bb2)</span></tt></td>
</tr>
<tr>
<td><tt>14:04.11</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad ``Erik
(~erik@pool-100-16-14-17.bltmmd.fios.verizon.net)</span></tt></td>
</tr>
<tr>
<td><tt>15:33.44</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad Caterpillar2
(~caterpill@unaffiliated/caterpillar)</span></tt></td>
</tr>
<tr>
<td><tt>16:26.18</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad d_rossberg
(~rossberg@104.225.5.10)</span></tt></td>
</tr>
<tr>
<td><tt>17:19.19</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad KimK
(~Kim__@2600:8803:7a81:7400:c1b9:9c23:aaf0:3cf0)</span></tt></td>
</tr>
<tr class="c4">
<td><tt>18:41.23</tt></td>
<td><span class="c3"><tt>Notify</tt></span></td>
<td width="100%"><tt>03BRL-CAD:Marco-domingues * 10018
/wiki/User:Marco-domingues/GSoC17/Log: 5 June</tt></td>
</tr>
<tr>
<td><tt>19:23.56</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad yorik
(~yorik@2804:431:f721:94ee:290:f5ff:fedc:3bb2)</span></tt></td>
</tr>
<tr>
<td><tt>19:36.42</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad LordOfBikes
(~armin@dslc-082-083-184-129.pools.arcor-ip.net)</span></tt></td>
</tr>
<tr>
<td><tt>19:37.50</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad vasc
(~vasc@bl13-101-248.dsl.telepac.pt)</span></tt></td>
</tr>
<tr class="c4">
<td><tt>19:38.25</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt><span class="c6">pokes at
mdtwenty[m]</span></tt></td>
</tr>
<tr class="c4">
<td><tt>19:50.44</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>there was a site with IRC logs for this
channel somewhere. someone got a link to the logs?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:07.18</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>Hey.. After our conversation last week, i came
up with a new solution to the weave_segs kernel. I tried first to
implement it without allocating a fixed size array to store the
segments in each partition, and although the number of partitions
per ray was correct, the segments in each partition were not and
the code was a bit messy. So I decided to first implement it with a
fixed array of segments in each partition (I</tt></td>
</tr>
<tr class="c4">
<td><tt>20:07.18</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>started with an array of 100 elements because
it was sufficient for the example) and the results seemed ok (i.e
the number of partitions  and segments in each partition after
boolean evaluation seemed correct for the example i am using to
test)</tt></td>
</tr>
<tr class="c4">
<td><tt>20:11.25</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i don't see how that makes things simpler
since it was bounded... but do continue.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:12.09</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>mdtwenty[m]</tt></td>
</tr>
<tr class="c4">
<td><tt>20:13.58</tt></td>
<td><span class="c8"><tt>starseeker</tt></span></td>
<td width="100%"><tt>Notify: irc</tt></td>
</tr>
<tr class="c4">
<td><tt>20:14.03</tt></td>
<td><span class="c8"><tt>starseeker</tt></span></td>
<td width="100%"><tt>hmm</tt></td>
</tr>
<tr class="c4">
<td><tt>20:14.42</tt></td>
<td><span class="c8"><tt>starseeker</tt></span></td>
<td width="100%"><tt>don't remember how that works</tt></td>
</tr>
<tr class="c4">
<td><tt>20:15.20</tt></td>
<td><span class="c8"><tt>starseeker</tt></span></td>
<td width="100%"><tt>vasc: I think you're looking for this? 
<a href=
"http://infobot.rikers.org/%23brlcad/">http://infobot.rikers.org/%23brlcad/</a></tt></td>
</tr>
<tr class="c4">
<td><tt>20:15.25</tt></td>
<td><span class="c9"><tt>gcibot_</tt></span></td>
<td width="100%"><tt>[ apt/ibot/infobot/purl logs for 2017
]</tt></td>
</tr>
<tr class="c4">
<td><tt>20:15.30</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>yes. that's it! thanks!</tt></td>
</tr>
<tr class="c4">
<td><tt>20:18.10</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>I tried to make it bounded first so it would
be easier to compare the results with a  new solution, but if we
were to alloc the array with the total number of segments, how we
could do that? Since we only know that number after the count_hits
kernel is executed</tt></td>
</tr>
<tr class="c4">
<td><tt>20:19.26</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>yeah but why would you need to know the size
before calling count_hits anyway?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:19.59</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>and when i tried to alloc the memory for that
array before creating the opencl bufer, it would take to much time
to execute comparing with the previous solution</tt></td>
</tr>
<tr class="c4">
<td><tt>20:20.23</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>eh?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:21.05</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>in theory you'll only need to allocate buffers
in the graphics card memory.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:22.02</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>opencl buffers.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:22.52</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i don't see how allocating a smaller buffer
will be slower than allocating a larger buffer. which is what will
happen if you have 100 segments per pixel.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.27</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>you're talking about this?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.28</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.28</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.28</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.28</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.28</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.30</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.32</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.34</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.36</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>BU_ASSERT((counts[i-1] % 2) == 0);</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.38</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>h[i] = h[i-1] + counts[i-1]/2;/* number of
segs is half the number of hits */</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.40</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.42</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.45</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>that code is only there because we don't have
opencl prefix sums implemented</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.51</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>When the buffer runs out, you can return
failure, realloc, then just try again with a bigger buffer and/or
fewer rays?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:27.53</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it should be done all in the opencl side
eventually.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:28.04</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>you won't need to realloc</tt></td>
</tr>
<tr class="c4">
<td><tt>20:28.11</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>man</tt></td>
</tr>
<tr class="c4">
<td><tt>20:28.55</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>IIRC the max amount of partitions is 2x the
amount of segments right?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:29.07</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>so you just allocate that as the maximum
buffer size.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:29.36</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>and then you dynamically grow the virtual
buffer, sure, but it will never go past the maximum buffer
size.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:31.06</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>I seriously lack context here, but the maximum
buffer size for buffering all hits through a complex scene can be
astronomical. It's very practical to "return failure and try
again", it almost never happens in practice</tt></td>
</tr>
<tr class="c4">
<td><tt>20:31.21</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>no it's not.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:32.00</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Counting hits first also isn't relible since
optimization of different kernels will produce slightly different
results... besides the whole problem of tracing rays
twice</tt></td>
</tr>
<tr class="c4">
<td><tt>20:32.24</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>allocating memory is much slower than counting
hits.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:32.40</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>You allocate once and reuse the same buffer
over and over</tt></td>
</tr>
<tr class="c4">
<td><tt>20:32.46</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>hm</tt></td>
</tr>
<tr class="c4">
<td><tt>20:32.57</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>sure that would work.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:33.04</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>but why bother.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:33.12</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>It's the most efficient solution?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:33.22</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt><span class="c6">has done exactly that in
another ray tracer...</span></tt></td>
</tr>
<tr class="c4">
<td><tt>20:33.24</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i would be happy with something that actually
works first.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:33.41</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Counting hits isn't reliable</tt></td>
</tr>
<tr class="c4">
<td><tt>20:33.49</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>why isn't it reliable?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:34.25</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Because the kernel to count hits and the
kernel to record hits are different. They use the same function,
but they will all be inlined by the compiler and optimized in
different rays</tt></td>
</tr>
<tr class="c4">
<td><tt>20:34.29</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Err, different ways*</tt></td>
</tr>
<tr class="c4">
<td><tt>20:35.02</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>so you're saying the opencl device won't
produce the same results if you run the same code twice? that it
isn't deterministic?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:35.21</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>It's not the same code, it's two different
kernels: counting hints and recording hits</tt></td>
</tr>
<tr class="c4">
<td><tt>20:35.33</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Unless you actually have one kernel that does
both with a branch. Less efficient though</tt></td>
</tr>
<tr class="c4">
<td><tt>20:35.47</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it's the exact same code. except one stores
the results and the other one doesn't.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:36.27</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>You do realize that everything OpenCL/CUDA is
preferably inlined in the calling device function as one big fat
function?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:36.41</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>And when you inline and optimize floating
point math, results differ slightly</tt></td>
</tr>
<tr class="c4">
<td><tt>20:36.50</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i don't see how that makes any difference in
the code results. unless the compiler has a bug.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:36.56</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>(a+b)+c != a+(b+c)</tt></td>
</tr>
<tr class="c4">
<td><tt>20:37.05</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>especially because they both call the same
exact functions.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:37.21</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>man, i have it running and it
works(tm)</tt></td>
</tr>
<tr class="c4">
<td><tt>20:37.37</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i count the hits, alloc a buffer for the hits,
and then store them</tt></td>
</tr>
<tr class="c4">
<td><tt>20:37.40</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>it's in SVN</tt></td>
</tr>
<tr class="c4">
<td><tt>20:37.42</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Okay, but it's not reliable if you enable
optimization</tt></td>
</tr>
<tr class="c4">
<td><tt>20:37.50</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>why shouldn't it be?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:38.24</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>_If_ you use two separate kernels, it's all
inlined and optimized separately, with slightly different
results</tt></td>
</tr>
<tr class="c4">
<td><tt>20:38.33</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>If you use a branch in the same kernel, it's
fine, but slower</tt></td>
</tr>
<tr class="c4">
<td><tt>20:38.37</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>no man. because it's THE SAME KERNEL</tt></td>
</tr>
<tr class="c4">
<td><tt>20:38.49</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>they only difference is a branch which either
stores the result or not.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:39.12</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>:-)</tt></td>
</tr>
<tr class="c4">
<td><tt>20:39.33</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Okay, and you end up tracing rays
twice</tt></td>
</tr>
<tr class="c4">
<td><tt>20:40.10</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>sure.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:40.17</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>which still beats re-allocating
memory.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:40.25</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>You don't reallocate!</tt></td>
</tr>
<tr class="c4">
<td><tt>20:40.49</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>sure. then you replace this simple to solve
problem with a more complex problem.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:40.50</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>When I did something similar/identical, I had
a batch of 32 buffers to store results (one buffer per
thread/lane), the offsets were incremented by atomics, and there
was a special flag to denote "I ran out of memory"</tt></td>
</tr>
<tr class="c4">
<td><tt>20:41.02</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>so which size of buffer will you allocate that
can use all the gpu compute units?</tt></td>
</tr>
<tr class="c4">
<td><tt>20:41.24</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>my solution doesn't require atomics
either.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:41.26</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>If that flag was ever set, you would
reallocate _or_ trace less rays. And you did that maybe once, if
the heuristics were off for the scene's complexity</tt></td>
</tr>
<tr class="c4">
<td><tt>20:41.29</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>its lockless.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:42.11</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Wait actually, it wasn't one buffer per
thread/lane, I was doing one atomic for the whole warp after
counting how much memory all of it required</tt></td>
</tr>
<tr class="c4">
<td><tt>20:42.21</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>The hits being buffered in on-chip shared
memory</tt></td>
</tr>
<tr class="c4">
<td><tt>20:42.55</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>atomics don't work on shared memory. they work
on global memory.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:43.00</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>at least in opencl it's like that.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:43.34</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>plus if you're doing inter-warp computation
you don't need atomics.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:43.59</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>You have both in CUDA... but the atomics were
for the global buffer, shared memory was only for accumulating many
hits before flushing to global (with one atomic operation to
allocate and flush the results of all threads of the
warp)</tt></td>
</tr>
<tr class="c4">
<td><tt>20:44.06</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>ah ok.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:44.22</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>you're still replacing a simple problem with a
more complex problem.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:44.38</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>It's a little complex, but it's much faster
than tracing twice</tt></td>
</tr>
<tr class="c4">
<td><tt>20:45.08</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>meh. there's way worse inneficiencies in the
code right now.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:45.26</tt></td>
<td><span class="c10"><tt>Stragus</tt></span></td>
<td width="100%"><tt>Okay then. :) Perhaps keep all this in mind
for a future iteration</tt></td>
</tr>
<tr class="c4">
<td><tt>20:45.37</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>sure.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:47.39</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>anyway mdtwenty[m], the problem with the
change you made is that you can't assume that buffer will be large
enough to hold the results.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:48.17</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>yes i'm aware</tt></td>
</tr>
<tr class="c4">
<td><tt>20:49.00</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>and perharps i did something wrong when i
tried to allocate the buffer for the array of segments in each
partition</tt></td>
</tr>
<tr class="c4">
<td><tt>20:49.25</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>at one point we actually computed that prefix
sum with opencl and did no memory transfers in that code, but the
thing is i was using a prefix sum code with an Apache Public
License code so it needed to be ripped out.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:49.54</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>will need to either get an MIT licensed
algorithm or reimplement it eventually.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:50.07</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>but for now it doesn't matter.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:50.15</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>well</tt></td>
</tr>
<tr class="c4">
<td><tt>20:50.23</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i wouldn't be surprised if there was a bug
there.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:50.53</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>its okay to try things with a simpler piece of
code for now, but eventually you need something that works
properly.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:51.58</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>yes the idea of implementing first this
simpler code was to have a base to compare the results with future
solutions</tt></td>
</tr>
<tr class="c4">
<td><tt>20:52.44</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>you could just make a mockup that returns
white when there are intersections and black when there are
none.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:52.52</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>so it would make debugging your results
easier.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:53.47</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i.e. a replacement for
clt_shade_segs_kernel</tt></td>
</tr>
<tr class="c4">
<td><tt>20:54.34</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>yes thanks i will do that</tt></td>
</tr>
<tr class="c4">
<td><tt>20:55.46</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>eventually you'll need to get the material
right as well.</tt></td>
</tr>
<tr class="c4">
<td><tt>20:56.20</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>where was that in the ANSI C code...</tt></td>
</tr>
<tr class="c4">
<td><tt>21:03.42</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>right</tt></td>
</tr>
<tr class="c4">
<td><tt>21:03.58</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt><a href=
"https://svn.code.sf.net/p/brlcad/code/brlcad/trunk/src/rt/view.c">https://svn.code.sf.net/p/brlcad/code/brlcad/trunk/src/rt/view.c</a></tt></td>
</tr>
<tr class="c4">
<td><tt>21:04.00</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>colorview()</tt></td>
</tr>
<tr class="c4">
<td><tt>21:05.32</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>the opencl rt is basically a mix of ANSI C
librt, liboptical and rt code...</tt></td>
</tr>
<tr class="c4">
<td><tt>21:05.46</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>with a lot of things deleted.</tt></td>
</tr>
<tr class="c4">
<td><tt>21:06.11</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>to make it something a human being can
understand.</tt></td>
</tr>
<tr class="c4">
<td><tt>21:06.45</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>of course most of those features will probably
need to be added back eventually.</tt></td>
</tr>
<tr class="c4">
<td><tt>21:14.01</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>sure :)</tt></td>
</tr>
<tr class="c4">
<td><tt>21:14.55</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>i will implement your suggestion of shading
the intersections with a different color to see it there is still a
problem with the weave_segs kernel</tt></td>
</tr>
<tr class="c4">
<td><tt>21:15.37</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>and will also work on replacing the bounded
array</tt></td>
</tr>
<tr class="c4">
<td><tt>21:19.09</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>just make sure to keep backups</tt></td>
</tr>
<tr class="c4">
<td><tt>21:19.43</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>once you get a black/white shader working then
message me.</tt></td>
</tr>
<tr class="c4">
<td><tt>21:23.17</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i also started with before i got the shading
working properly:</tt></td>
</tr>
<tr class="c4">
<td><tt>21:23.19</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt><a href=
"https://brlcad.org/w/images/thumb/8/87/Cl_havoc.png/512px-Cl_havoc.png">
https://brlcad.org/w/images/thumb/8/87/Cl_havoc.png/512px-Cl_havoc.png</a></tt></td>
</tr>
<tr class="c4">
<td><tt>21:25.04</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>s/started with/started with the
black&amp;white shader</tt></td>
</tr>
<tr class="c4">
<td><tt>21:25.23</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>yes it is definitely a good idea</tt></td>
</tr>
<tr class="c4">
<td><tt>21:26.07</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>i will implement that and will give you a
heads up when its done :)</tt></td>
</tr>
<tr class="c4">
<td><tt>21:38.02</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>okay then</tt></td>
</tr>
<tr class="c4">
<td><tt>21:38.32</tt></td>
<td><span class="c5"><tt>vasc</tt></span></td>
<td width="100%"><tt>i notice you've been updating your blog, so
keep at it</tt></td>
</tr>
<tr class="c4">
<td><tt>21:43.38</tt></td>
<td><span class="c7"><tt>mdtwenty[m]</tt></span></td>
<td width="100%"><tt>yes i will keep posting my daily progress on
the blog!</tt></td>
</tr>
<tr>
<td><tt>23:20.34</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad kintel
(~kintel@unaffiliated/kintel)</span></tt></td>
</tr>
<tr>
<td><tt>23:40.31</tt></td>
<td colspan="2"><tt><span class="c2">*** join/#brlcad teepee
(~teepee@unaffiliated/teepee)</span></tt></td>
</tr>
</table>
<br />
Generated by irclog2html.pl Modified by <a href=
"http://Rikers.org">Tim Riker</a> to work with <a href=
"http://infobot.sourceforge.net/">infobot</a>.
</body>
</html>
