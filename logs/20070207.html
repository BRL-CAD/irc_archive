<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.6.0" />
<title>irclog2html for #brlcad on 20070207</title>
<meta name="generator" content="irclog2html.pl by Jeff Waugh" />
<meta name="version" content="Version 1.5 - 11th May 2000" />
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<style type="text/css">
/*<![CDATA[*/
 body {
  background-color: #FFFFFF;
  color: #000000;
 }
 span.c12 {color: #5F5FB5}
 span.c11 {color: #5FB55F}
 span.c10 {color: #DD74DD}
 span.c9 {color: #6ACBCB}
 span.c8 {color: #009900}
 span.c7 {color: #BB6262}
 span.c6 {color: #75DF75}
 span.c5 {color: #6767C5}
 span.c4 {color: #B5B55F}
 span.c3 {color: #D570D5}
 tr.c2 {background-color: #EEEEEE}
 span.c1 {color: #6DCF6D}
/*]]>*/
</style>
</head>
<body>
<h1>irclog2html for #brlcad on 20070207</h1>
<table cellspacing="3" cellpadding="2" border="0">
<tr class="c2">
<td><tt>00:07.55</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>mac-: there is fairly extensive introductory
material on the main website:  <a href=
"http://brlcad.org">http://brlcad.org</a></tt></td>
</tr>
<tr class="c2">
<td><tt>00:08.17</tt></td>
<td><span class="c3"><tt>mac-</tt></span></td>
<td width="100%"><tt>ok</tt></td>
</tr>
<tr class="c2">
<td><tt>00:08.21</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ah, oop.. thx louipc  :)  I should finish
reading first..</tt></td>
</tr>
<tr class="c2">
<td><tt>00:08.28</tt></td>
<td><span class="c3"><tt>mac-</tt></span></td>
<td width="100%"><tt>do you know any good CAD for Linux ?</tt></td>
</tr>
<tr class="c2">
<td><tt>00:09.17</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>er, you mean other than brl-cad?</tt></td>
</tr>
<tr class="c2">
<td><tt>00:09.26</tt></td>
<td><span class="c3"><tt>mac-</tt></span></td>
<td width="100%"><tt>for drafting</tt></td>
</tr>
<tr class="c2">
<td><tt>00:09.33</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ah.. CADD</tt></td>
</tr>
<tr class="c2">
<td><tt>00:09.38</tt></td>
<td><span class="c3"><tt>mac-</tt></span></td>
<td width="100%"><tt>similar to AutoCAD</tt></td>
</tr>
<tr class="c2">
<td><tt>00:10.06</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the only readily available one is
qcad</tt></td>
</tr>
<tr class="c2">
<td><tt>00:10.22</tt></td>
<td><span class="c3"><tt>mac-</tt></span></td>
<td width="100%"><tt>uhm</tt></td>
</tr>
<tr class="c2">
<td><tt>00:10.43</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>(free at least)</tt></td>
</tr>
<tr class="c2">
<td><tt>00:10.50</tt></td>
<td><span class="c3"><tt>mac-</tt></span></td>
<td width="100%"><tt>i downloaded GraphiteOne, but i couldn`t
launch it</tt></td>
</tr>
<tr class="c2">
<td><tt>00:10.51</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>and with any production quality</tt></td>
</tr>
<tr class="c2">
<td><tt>00:11.19</tt></td>
<td><span class="c3"><tt>mac-</tt></span></td>
<td width="100%"><tt>and their support hasn`t reply for my
questions</tt></td>
</tr>
<tr class="c2">
<td><tt>00:12.47</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ah, I don't follow the commercial products
that closely, even less those specific to drafting, even further
less those that aren't open source</tt></td>
</tr>
<tr class="c2">
<td><tt>00:13.05</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>(sorry, just not our
concern/interest)</tt></td>
</tr>
<tr class="c2">
<td><tt>00:13.21</tt></td>
<td><span class="c3"><tt>mac-</tt></span></td>
<td width="100%"><tt>ok</tt></td>
</tr>
<tr class="c2">
<td><tt>00:13.24</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>I saw one called FreeCAD on sourceforge, I
haven't tried it yet</tt></td>
</tr>
<tr class="c2">
<td><tt>00:13.57</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>freecad is mildly useful, but they're even
farther from production quality than qcad</tt></td>
</tr>
<tr class="c2">
<td><tt>00:14.03</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>ouch</tt></td>
</tr>
<tr class="c2">
<td><tt>00:14.55</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it just really takes too much time to build up
the foundation for a CAD or CADD or CAM system to achieve
production quality for generalized use</tt></td>
</tr>
<tr class="c2">
<td><tt>00:15.12</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>might find a tool or two specialized</tt></td>
</tr>
<tr class="c2">
<td><tt>00:15.56</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>but freecad and qcad and pythoncad and others
try to cater to common audiences, and have a excessively major hill
to fight</tt></td>
</tr>
<tr class="c2">
<td><tt>00:17.18</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>yeah definitely</tt></td>
</tr>
<tr class="c2">
<td><tt>00:17.44</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>that's one of the aspects where brl-cad shines
-- even if you remove mged and the gui, there's roughly 100+
man-years of development</tt></td>
</tr>
<tr class="c2">
<td><tt>00:18.40</tt></td>
<td><span class="c5"><tt>dtidrow_work</tt></span></td>
<td width="100%"><tt>and at least 25 real years of development
behind it</tt></td>
</tr>
<tr class="c2">
<td><tt>00:18.59</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>do you think you can achieve a professional
level GUI with tcl/tk?</tt></td>
</tr>
<tr class="c2">
<td><tt>00:32.04</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>given the # of gui's professionally developed
in tcl/tk... probably...</tt></td>
</tr>
<tr class="c2">
<td><tt>00:46.17</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>louipc: you can, and even brl-cad's archer
shows a lot of what is possible in terms of a better gui more in
line with several of the professional system interfaces</tt></td>
</tr>
<tr class="c2">
<td><tt>00:46.37</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>that said, our next generation gui probably
won't be in tcl/tk</tt></td>
</tr>
<tr class="c2">
<td><tt>00:53.56</tt></td>
<td><span class="c7"><tt>bjorkBSD</tt></span></td>
<td width="100%"><tt>but ... i thought brl-cad *was*
professional!</tt></td>
</tr>
<tr class="c2">
<td><tt>00:54.21</tt></td>
<td><span class="c7"><tt>bjorkBSD</tt></span></td>
<td width="100%"><tt>brilly wears a uniform no?</tt></td>
</tr>
<tr class="c2">
<td><tt>01:00.38</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>a professional-quality gui? no, that's one of
the things it does lack .. in production professional use with
professional-quality engine facilities, yes</tt></td>
</tr>
<tr class="c2">
<td><tt>01:02.23</tt></td>
<td><span class="c7"><tt>bjorkBSD</tt></span></td>
<td width="100%"><tt>what will the next gui be in?</tt></td>
</tr>
<tr class="c2">
<td><tt>01:03.54</tt></td>
<td><span class="c7"><tt>bjorkBSD</tt></span></td>
<td width="100%"><tt>in the beginning was the CL, and lo, man took
one look at the CLI and thought it was bad. and man created the
mouse to eat the CL but verily verily i say unto ye, the CLI served
as a useful barrier to entry and kept the waifs away :D</tt></td>
</tr>
<tr class="c2">
<td><tt>01:08.40</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>@brlcad what are you considering for the next
GUI?</tt></td>
</tr>
<tr class="c2">
<td><tt>01:10.14</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>bjorkBSD: hehe I find the CLI can actually be
more efficient if you know what you're doing, and it is well
designed</tt></td>
</tr>
<tr class="c2">
<td><tt>01:12.11</tt></td>
<td><span class="c7"><tt>bjorkBSD</tt></span></td>
<td width="100%"><tt>yeah. i hear vista's reintroduced it
:D</tt></td>
</tr>
<tr class="c2">
<td><tt>01:12.38</tt></td>
<td><span class="c7"><tt>bjorkBSD</tt></span></td>
<td width="100%"><tt>as far as command line completion
goes.</tt></td>
</tr>
<tr class="c2">
<td><tt>01:12.54</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>oh tab completion?</tt></td>
</tr>
<tr class="c2">
<td><tt>01:13.15</tt></td>
<td><span class="c7"><tt>bjorkBSD</tt></span></td>
<td width="100%"><tt>something like that. i saw it in a youtube
video</tt></td>
</tr>
<tr class="c2">
<td><tt>01:13.36</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>I've heard bad things about vista, and not
from windows users nonetheless</tt></td>
</tr>
<tr class="c2">
<td><tt>01:13.37</tt></td>
<td><span class="c7"><tt>bjorkBSD</tt></span></td>
<td width="100%"><tt>... they've had it in iexplorer for ages, but
it seems it's use has been broadened.</tt></td>
</tr>
<tr class="c2">
<td><tt>01:14.21</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>I tried XP because a linux user said it was
the best thing since 3.1 or something. That didn't last for me
hah.</tt></td>
</tr>
<tr class="c2">
<td><tt>01:14.32</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>bad things... *and from windows
users...</tt></td>
</tr>
<tr class="c2">
<td><tt>01:14.46</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>typo</tt></td>
</tr>
<tr class="c2">
<td><tt>01:14.50</tt></td>
<td><span class="c7"><tt>bjorkBSD</tt></span></td>
<td width="100%"><tt>hehe</tt></td>
</tr>
<tr class="c2">
<td><tt>01:15.08</tt></td>
<td><span class="c7"><tt>bjorkBSD</tt></span></td>
<td width="100%"><tt>i have a windows partition i reboot to every
now and then.</tt></td>
</tr>
<tr>
<td><tt>02:21.32</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad bobbens
(n=bobbens@84.16.237.134)</span></tt></td>
</tr>
<tr class="c2">
<td><tt>04:44.31</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Could anyone tell me what's the common memory
and processing models within HPC clusters? I received from a
non-programmer by email information that conflicts with my
assumptions</tt></td>
</tr>
<tr class="c2">
<td><tt>04:44.39</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Keywords to wikipedia would do too</tt></td>
</tr>
<tr>
<td><tt>04:46.16</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad PrezKennedy
(n=Matthew@c-69-138-68-160.hsd1.md.comcast.net)</span></tt></td>
</tr>
<tr class="c2">
<td><tt>06:36.10</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>louipc: the CLI is not going away in the least
and would actually be more a part of the foundation to the
interface (e.g. anything you could do in the gui would be exposed
on the cli and vice-versa)</tt></td>
</tr>
<tr class="c2">
<td><tt>06:39.55</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it would be just more of a focus on designing
a gui that actually works, is efficient, more consistent, is
readily pluggable, and not nearly as much of a bear to
maintain/improve as mged's is</tt></td>
</tr>
<tr class="c2">
<td><tt>06:41.41</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Nevermind the question about cluster
processing, Mark had some... weird ideas on the topic :)</tt></td>
</tr>
<tr class="c2">
<td><tt>06:43.43</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>most custom designs in general with data
localized/replicated in-core or is spread across some out-of-core
storage and loaded as needed</tt></td>
</tr>
<tr class="c2">
<td><tt>06:48.24</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>most don't have shared process spaces or
shared address spaces, but often have shared storage (but not
always) so it usually boils down to whether disk memory is
sufficient or whether to optimize replicaton/distribution over some
communication pipe like tcp sockets, mpi, pvm, etc</tt></td>
</tr>
<tr class="c2">
<td><tt>06:49.30</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Shared address spaces, that exists?</tt></td>
</tr>
<tr class="c2">
<td><tt>06:49.44</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>It goes against all I know, but it was what
Mark apparently assumed</tt></td>
</tr>
<tr class="c2">
<td><tt>06:50.42</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>there's a few systems that do, some
experimental, some more production</tt></td>
</tr>
<tr class="c2">
<td><tt>06:51.54</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Woah... but..</tt></td>
</tr>
<tr class="c2">
<td><tt>06:52.38</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>If the memory address space is shared, it must
be a single system made of multiple processors ; you have one
memory bank</tt></td>
</tr>
<tr class="c2">
<td><tt>06:53.07</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>It wouldn't be too reasonable to get a page
fault for every memory access and synchronize with other processing
nodes constantly</tt></td>
</tr>
<tr class="c2">
<td><tt>06:53.35</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>not necessarily -- the kernel is simply
written/geared towards managing the memory</tt></td>
</tr>
<tr class="c2">
<td><tt>06:53.51</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>that's the whole idea around single shared
image systems in general</tt></td>
</tr>
<tr class="c2">
<td><tt>06:54.03</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>mosix is probably the most popular/common one
that you might have heard about</tt></td>
</tr>
<tr class="c2">
<td><tt>06:54.06</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>or openmosix</tt></td>
</tr>
<tr class="c2">
<td><tt>06:54.19</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ahh, here's some references <a href=
"http://en.wikipedia.org/wiki/Single-system_image">http://en.wikipedia.org/wiki/Single-system_image</a></tt></td>
</tr>
<tr class="c2">
<td><tt>06:54.35</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I really don't see how this could possibly
work</tt></td>
</tr>
<tr class="c2">
<td><tt>06:55.07</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The only way for the kernel to know what
memory is being modified or accessed is to trigger page
faults</tt></td>
</tr>
<tr class="c2">
<td><tt>06:56.18</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>they do work ;)</tt></td>
</tr>
<tr class="c2">
<td><tt>06:56.27</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>to varying degrees of coolness</tt></td>
</tr>
<tr class="c2">
<td><tt>06:56.33</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Do you have any idea how, briefly?</tt></td>
</tr>
<tr class="c2">
<td><tt>06:56.44</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>mosix gets away with it by simply migrating
processes to balance load</tt></td>
</tr>
<tr class="c2">
<td><tt>06:56.45</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>How can they track what's being read or
written to synchronize the data?</tt></td>
</tr>
<tr class="c2">
<td><tt>06:56.58</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Yes, they can migrate processes, but they
won't share address space</tt></td>
</tr>
<tr class="c2">
<td><tt>06:57.09</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>You couldn't get shared memory between
processes</tt></td>
</tr>
<tr class="c2">
<td><tt>06:57.15</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>right, that's why they're only a partial
SSI</tt></td>
</tr>
<tr class="c2">
<td><tt>06:57.42</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>there is still one shared address space, but
it's no bigger than the smallest single system's available
memory</tt></td>
</tr>
<tr class="c2">
<td><tt>06:58.07</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>which isn't entirely true .. but a simple
enough simplification</tt></td>
</tr>
<tr class="c2">
<td><tt>06:58.13</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>How can they possibly synchronize that
memory?</tt></td>
</tr>
<tr class="c2">
<td><tt>06:58.57</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>they don't really need too -- the process
moves with it's memory</tt></td>
</tr>
<tr class="c2">
<td><tt>06:59.49</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Yes, yes, moving processes around is fine. 
Now, let's say you have process A on the box M and process B on the
box N. The two processes have 160mb allocated as shared memory
which they use to communicate</tt></td>
</tr>
<tr class="c2">
<td><tt>07:00.14</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>How are they going to manage and synchornize
that memory between the two nodes?</tt></td>
</tr>
<tr class="c2">
<td><tt>07:00.53</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>that's the entire question behind just how do
you do SSI</tt></td>
</tr>
<tr class="c2">
<td><tt>07:01.00</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>each of those ssi projects goes about it a
different way</tt></td>
</tr>
<tr>
<td><tt>07:01.05</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad clock_
(i=clock@84-72-63-172.dclient.hispeed.ch)</span></tt></td>
</tr>
<tr class="c2">
<td><tt>07:01.22</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I see no other way than constant page faults,
which would make performance crawl</tt></td>
</tr>
<tr class="c2">
<td><tt>07:01.25</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>some are compiler mods coupled with specific
kernels that are fed information about memory access</tt></td>
</tr>
<tr class="c2">
<td><tt>07:01.55</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>just because you can't imagine it doesn't mean
someone else hasn't :)</tt></td>
</tr>
<tr class="c2">
<td><tt>07:02.14</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I know that, but I'm asking how it works! :) I
guess I should do some reading</tt></td>
</tr>
<tr class="c2">
<td><tt>07:03.24</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>well, you might also be thinking shared memory
== shared address space and it doesn't</tt></td>
</tr>
<tr class="c2">
<td><tt>07:03.33</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>at least not necessarily</tt></td>
</tr>
<tr class="c2">
<td><tt>07:04.07</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>whether you even can write C code on a lot of
those systems is not possible -- some are very customized academic
projects</tt></td>
</tr>
<tr class="c2">
<td><tt>07:04.24</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>brlcad, the box M needs to "know" when the
process A writes within the shard memory, so it can update it on
box N</tt></td>
</tr>
<tr class="c2">
<td><tt>07:05.00</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Okay, Mosix doesn't support shared
memory</tt></td>
</tr>
<tr class="c2">
<td><tt>07:05.07</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>with shared memory -- sure, and there's ways a
kernel could be written to propagate that</tt></td>
</tr>
<tr class="c2">
<td><tt>07:05.19</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>yes, mosix doesn't</tt></td>
</tr>
<tr class="c2">
<td><tt>07:05.59</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it does process migration in a unified process
address space</tt></td>
</tr>
<tr class="c2">
<td><tt>07:05.59</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The kernel must be told by the processor that
writes occur to begin with ; that implies a page fault</tt></td>
</tr>
<tr class="c2">
<td><tt>07:06.29</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>implies a "fault" of some sort .. whether
memory is managed in pages is an assumption in itself</tt></td>
</tr>
<tr class="c2">
<td><tt>07:06.55</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>whether that maps to hardware fault is yet
another</tt></td>
</tr>
<tr class="c2">
<td><tt>07:07.33</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Right, of course so. What I'm trying to say is
that page faults, specifically assuming ia32/amd64 hardware, would
cripple performance</tt></td>
</tr>
<tr class="c2">
<td><tt>07:08.08</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i believe openssi actually does shared memory
across a unified address space</tt></td>
</tr>
<tr class="c2">
<td><tt>07:08.17</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>though I haven't looked into how they actually
achieved it</tt></td>
</tr>
<tr class="c2">
<td><tt>07:09.04</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>hey, you can't get it all for free -- if
you're going to be accessing memory across a network link,
performance is going to be crippled no matter how creative you
get</tt></td>
</tr>
<tr class="c2">
<td><tt>07:10.05</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i mean you're talking the difference of a
couple clock cycles to a few nanosecs at best</tt></td>
</tr>
<tr class="c2">
<td><tt>07:10.34</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>which is of course...several orders</tt></td>
</tr>
<tr class="c2">
<td><tt>07:10.49</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the fact that it'll even do it (and do it
automatically) is what's amazing</tt></td>
</tr>
<tr class="c2">
<td><tt>07:11.12</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>just getting it to work at all has been
something groups have been working on for longer than I've been
alive :)</tt></td>
</tr>
<tr class="c2">
<td><tt>07:11.19</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I'm asking this because Mark had the
assumption that clusters could share memory address space, running
threads over the processing network, which is of course
incorrect</tt></td>
</tr>
<tr class="c2">
<td><tt>07:11.34</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>But I thought there could be some weird
cluster architecture I wasn't aware of</tt></td>
</tr>
<tr class="c2">
<td><tt>07:12.04</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>nobody does individual thread-level yet afaik
.. even mosix only does process-level</tt></td>
</tr>
<tr class="c2">
<td><tt>07:12.16</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>though openssi does thread-group migration
iirc, one step closer</tt></td>
</tr>
<tr class="c2">
<td><tt>07:12.59</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I don't know if it's really amazing, it's
absolutely horrible by design :)</tt></td>
</tr>
<tr class="c2">
<td><tt>07:13.21</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>openssi might be what he was thinking .. or
mosix for that matter and he really just meant unified address
space instead of shared and running processes over the network
instead of threads</tt></td>
</tr>
<tr class="c2">
<td><tt>07:13.38</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>horrible??</tt></td>
</tr>
<tr class="c2">
<td><tt>07:13.58</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>If you want to distribute processing over a
network, just write the software as such</tt></td>
</tr>
<tr class="c2">
<td><tt>07:14.18</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>some of those systems are nearly optimal for
doing exactly that</tt></td>
</tr>
<tr class="c2">
<td><tt>07:14.18</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>with zero effort on your part</tt></td>
</tr>
<tr class="c2">
<td><tt>07:14.53</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Without shared memory, I still need to handle
I/O between processes, I haven't gained anything</tt></td>
</tr>
<tr class="c2">
<td><tt>07:15.39</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>perhaps, or maybe you have an application that
is already well-designed to not have that assumption or need for
interprocess communication</tt></td>
</tr>
<tr class="c2">
<td><tt>07:15.59</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>you're making a ton of assumptions about what
matters, assumptions that don't hold for a lot of cases</tt></td>
</tr>
<tr class="c2">
<td><tt>07:16.37</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Right, I should clarify : I'm thinking about
distributed processing for a single problem, not running 100
distinct processes</tt></td>
</tr>
<tr class="c2">
<td><tt>07:17.09</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it also depends on the nature of the problem
itself of course</tt></td>
</tr>
<tr class="c2">
<td><tt>07:17.38</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>if you have a problem that can be
independently parallelized, it can likely also be independently
distributed seamlessly</tt></td>
</tr>
<tr class="c2">
<td><tt>07:18.10</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>(with a given architecture (software and
hardware)</tt></td>
</tr>
<tr class="c2">
<td><tt>07:18.25</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>True, but then there isn't much to gain from
"apparently" running the 100 processes "locally" rather than
booting them on the 100 boxes. It's a bit easier to manage
surely</tt></td>
</tr>
<tr class="c2">
<td><tt>07:18.56</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>whether there's much to gain depends on the
problem too :)</tt></td>
</tr>
<tr class="c2">
<td><tt>07:19.03</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>something short-lived, yeah, not much
gain</tt></td>
</tr>
<tr class="c2">
<td><tt>07:19.15</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>something like the life of your rays, yeah not
much gain</tt></td>
</tr>
<tr class="c2">
<td><tt>07:19.32</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>something that took minutes/days/weeks to
process.. it'd be incredibly useful</tt></td>
</tr>
<tr class="c2">
<td><tt>07:19.37</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I see the point but it's really a matter of
convenience, an user could start the processes on the other boxes
"manually" too</tt></td>
</tr>
<tr class="c2">
<td><tt>07:19.57</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>sure, but then I could have done that
anyways..</tt></td>
</tr>
<tr class="c2">
<td><tt>07:20.12</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the point of the cluster is to do that stuff
for you with the least effort</tt></td>
</tr>
<tr class="c2">
<td><tt>07:20.46</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>sometimes that least effort is by custom
coding or using mpi or it's by going with a different cluster
architecture that does things for you</tt></td>
</tr>
<tr class="c2">
<td><tt>07:20.56</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Right, so it's a matter of convenience, I
realize that</tt></td>
</tr>
<tr class="c2">
<td><tt>07:21.04</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>most of the popular (massive) clusters don't
do SSI</tt></td>
</tr>
<tr class="c2">
<td><tt>07:21.17</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i think HP's cluster tech does, but nobody
else</tt></td>
</tr>
<tr class="c2">
<td><tt>07:21.34</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>everyone else predominantly is geared towards
mpi</tt></td>
</tr>
<tr class="c2">
<td><tt>07:23.07</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>that's what the network cards are optimizing
for, the network stacks, etc.. if you want to efficiently scale up
to 10k processors and not have to worry (as much) about
bottlenecking yourself with interprocess/thread communication, mpi
can help (even as heavy as it can be otherwise)</tt></td>
</tr>
<tr class="c2">
<td><tt>07:24.15</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Yes, MPI is a neat abstraction layer, I won't
contest that :)</tt></td>
</tr>
<tr class="c2">
<td><tt>07:24.58</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>course if your problem can take advantage of
10k processors or even 1k easily.. then there's not much advantage
to be had by the alternative of custom coding some network layer
yourself to avoid mpi's (variable) overhead .. even a "2x" savings
on something that takes two weeks to compute isn't that
interesting</tt></td>
</tr>
<tr class="c2">
<td><tt>07:26.25</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>because those are generally problems that are
entirely intractible/unfeasible/useless on smaller
supercomputers</tt></td>
</tr>
<tr class="c2">
<td><tt>07:27.44</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it's still "at least a couple years" out
before I'll be able to do a full-blown fluid dynamics simulation on
a dual quad-core workstation to say the least.. ;)</tt></td>
</tr>
<tr class="c2">
<td><tt>07:28.16</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>:) Seems I'll have a chance to try that out
soon</tt></td>
</tr>
<tr class="c2">
<td><tt>07:28.50</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>full-blown valid-physics down to something
like millimeter accuracy at least</tt></td>
</tr>
<tr class="c2">
<td><tt>07:29.01</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I have only read documentation and code about
MPI, I'll try to move on from TCP/IP soon</tt></td>
</tr>
<tr class="c2">
<td><tt>07:29.23</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>there are tons of simplifications that can be
made on an fluid problem to get them to work on workstations
already</tt></td>
</tr>
<tr class="c2">
<td><tt>07:29.51</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I'll probably get to rewrite SURVICE's fire
simulation soon ( fluid dynamics ), it's really filled with
simplifications</tt></td>
</tr>
<tr class="c2">
<td><tt>07:29.53</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>MPI isn't "great" .. it's been so painful to
achieve adoption because the API is a pita</tt></td>
</tr>
<tr class="c2">
<td><tt>07:30.36</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>but it's like democracy .. it's not great, but
it's the best to have been conceived, adopted, and popularized to
date</tt></td>
</tr>
<tr class="c2">
<td><tt>07:30.37</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The API of MPI seemed appropriate for its
purpose... I may think differently when I get to use it</tt></td>
</tr>
<tr class="c2">
<td><tt>07:30.48</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it's gotten tons better</tt></td>
</tr>
<tr class="c2">
<td><tt>07:31.43</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I was baffled by how slow SURVICE's fire
modelling was, especially when I heard how much they simplified the
problem. Never let engineers write code, in Fortran 77
too</tt></td>
</tr>
<tr class="c2">
<td><tt>07:37.52</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>If I may, how much is there to lose by using
MPI over more tailored specific solutions, for software running on
1-4 nodes or so?</tt></td>
</tr>
<tr class="c2">
<td><tt>07:52.58</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>mpi for 1-4 nodes is frankly pointless -- that
could just as easily be a command line option for that few
nodes</tt></td>
</tr>
<tr class="c2">
<td><tt>07:55.06</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>--run-on="node1, node2, node3, node4" etc..
fork a master than remote execs to the nodes or something else ..
heck of a lot simpler code and trivial to manage the communication
between them without worring about a major bottleneck</tt></td>
</tr>
<tr class="c2">
<td><tt>07:56.42</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it's only once it's over like 16 that it
starts to get "hard" imho and things start to matter</tt></td>
</tr>
<tr class="c2">
<td><tt>07:57.38</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>how much you loose depends on lot on how many
MPI calls you make and how much interprocess/thread communication
is going on (which you generally want to minimize of course as much
as possible)</tt></td>
</tr>
<tr class="c2">
<td><tt>07:58.59</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>compared to strait-up custom tcp, I've seen
the mpi overhead be as low as only a couple percent to being a
couple hundred</tt></td>
</tr>
<tr class="c2">
<td><tt>08:00.05</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the main benefit of course being that tcp was
easy to write for smaller counts of nodes .. but quickly doesn't
scale for larger and larger node counts where mpi scales
considerably better and doesn't have to be
maintained/debugged/tweaked</tt></td>
</tr>
<tr>
<td><tt>08:45.18</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad clock_
(n=clock@zux221-122-143.adsl.green.ch)</span></tt></td>
</tr>
<tr>
<td><tt>14:04.08</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad docelic
(n=docelic@212.15.185.210)</span></tt></td>
</tr>
<tr class="c2">
<td><tt>15:30.07</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Thanks for the reply, brlcad, I was asleep by
then</tt></td>
</tr>
<tr class="c2">
<td><tt>15:39.28</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>mal: have ya read up on 'numa'?</tt></td>
</tr>
<tr class="c2">
<td><tt>15:39.52</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Sure, some time ago</tt></td>
</tr>
<tr class="c2">
<td><tt>15:40.39</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hrm, didja forget it? :D (given your
conversation before you went to bed, I'd assume...)</tt></td>
</tr>
<tr class="c2">
<td><tt>15:40.53</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>We should store a whole copy of geometry and
graphs per memory bank, and have specific threads access it... but
I haven't read about the software interfaces to do so</tt></td>
</tr>
<tr class="c2">
<td><tt>15:41.15</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it's a cluster form with a unified memory
space on several independant nodes, each with its own cpu and
memory...</tt></td>
</tr>
<tr class="c2">
<td><tt>15:41.16</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The discussion wasn't really related to NUMA,
it was about distributed processing over multiple nodes</tt></td>
</tr>
<tr class="c2">
<td><tt>15:42.10</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The count of processors in such a design is
kept very low, is it not? Up to 16 for an
octo-dual-opteron</tt></td>
</tr>
<tr class="c2">
<td><tt>15:42.24</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>an altix is a numa cluster of small single cpu
ia64 machines using sgi's numalink to get unsucky bandwidth between
'em and a hacked up suse to handle processor and memory
affinity</tt></td>
</tr>
<tr class="c2">
<td><tt>15:43.15</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That's one single machine though, not a
cluster</tt></td>
</tr>
<tr class="c2">
<td><tt>15:43.23</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>no, it's a cluster</tt></td>
</tr>
<tr class="c2">
<td><tt>15:43.51</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>if I walk up to one, it's a bunch of seperat
2u machines, I could pull the numa cables off the back, put in a
hard drive and install an os on that one machine</tt></td>
</tr>
<tr class="c2">
<td><tt>15:44.21</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt><a href=
"http://www.gup.uni-linz.ac.at/information/hardware/altix350_front.jpg">
http://www.gup.uni-linz.ac.at/information/hardware/altix350_front.jpg</a></tt></td>
</tr>
<tr class="c2">
<td><tt>15:44.24</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Do opteron clusters work the same
way?</tt></td>
</tr>
<tr class="c2">
<td><tt>15:45.15</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it doesn't matter what the cpu is, it depends
on the kernel and interconnect (using something like ethernet would
make it absolutely horrible)</tt></td>
</tr>
<tr class="c2">
<td><tt>15:46.04</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>So the Opteron clusters Mark spoke of do have
an unified memory space?</tt></td>
</tr>
<tr class="c2">
<td><tt>15:46.06</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>the opteron clusters I have are not numa,
they're regular ethernet tcp/ip nodes, each with independant
kernels that don't try to assume anything about eachother, and a
single disk attachment</tt></td>
</tr>
<tr class="c2">
<td><tt>15:46.16</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I don't know which clusters mark spoke of...
:)</tt></td>
</tr>
<tr class="c2">
<td><tt>15:46.56</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>So opteron clusters do exist having a global
memory address space by NUMA?</tt></td>
</tr>
<tr class="c2">
<td><tt>15:47.32</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I would be surprised if they didn't *shrug*
like I said, what cpu it is and NUMA are unrelated</tt></td>
</tr>
<tr class="c2">
<td><tt>15:48.35</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I could take a stack of old 486's running
10baseT and hack up a numa kernel for 'em... it'd suck, but it's
doable</tt></td>
</tr>
<tr class="c2">
<td><tt>15:48.39</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>or, heh, numaPIC :D</tt></td>
</tr>
<tr class="c2">
<td><tt>15:48.50</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>It's certainly not running on a standard
motherboard then!</tt></td>
</tr>
<tr class="c2">
<td><tt>15:49.05</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>sure it is... numa is a kernel hack</tt></td>
</tr>
<tr class="c2">
<td><tt>15:49.32</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>NUMA is a hardware solution</tt></td>
</tr>
<tr class="c2">
<td><tt>15:49.32</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>ok, if you miss on level1 cache, it goes to
level3... if it misses there, maybe it goes to memory... if it
misses there, it goes to swap, right?</tt></td>
</tr>
<tr class="c2">
<td><tt>15:49.51</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That's not a kernel solution until it misses
memory and trigger a page fault</tt></td>
</tr>
<tr class="c2">
<td><tt>15:49.52</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>shove 'other nodes' inbetween memory and swap,
that's numa</tt></td>
</tr>
<tr class="c2">
<td><tt>15:50.03</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>no, numa is a kernel hack that lets you fake
unified memory</tt></td>
</tr>
<tr class="c2">
<td><tt>15:50.08</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>NUMALink is a hardware solution</tt></td>
</tr>
<tr class="c2">
<td><tt>15:50.09</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>A page fault per memory access is not
practical</tt></td>
</tr>
<tr class="c2">
<td><tt>15:50.22</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>yeah it is, IF you have a low latency
interconnect</tt></td>
</tr>
<tr class="c2">
<td><tt>15:50.36</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>which is what NUMALink is... sgi's proprietary
interconnect, designed with numa archs in mind</tt></td>
</tr>
<tr class="c2">
<td><tt>15:51.01</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>You would spend 50000 times the processing
time of *one* memory-accessing instruction to handle that page
fault!</tt></td>
</tr>
<tr class="c2">
<td><tt>15:51.08</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>ib and myra could probably do it semi-decently
if your kernels scheduler was very aware of affinity</tt></td>
</tr>
<tr class="c2">
<td><tt>15:51.40</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>the trick is that migrations are minimized...
if a processor is happily using 1 node, it'll try to keep it on
that node...</tt></td>
</tr>
<tr class="c2">
<td><tt>15:51.56</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>if two apps are sharing memory, it'll bias
towards running both of those on that one node</tt></td>
</tr>
<tr class="c2">
<td><tt>15:52.50</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(and accessing another nodes memory, if you're
using a decent interconnect (like NUMALink for the altix) may be an
order of magnitude slower than local memory, but is several orders
better than swap</tt></td>
</tr>
<tr class="c2">
<td><tt>15:52.52</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>)</tt></td>
</tr>
<tr class="c2">
<td><tt>15:53.16</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I see, so it does work by page
faults</tt></td>
</tr>
<tr class="c2">
<td><tt>15:53.42</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>if the underlying arch does, I'd imagine it'd
have to</tt></td>
</tr>
<tr class="c2">
<td><tt>15:54.15</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>NUMA as implemented in an Opteron system is
really fast, memory banks bound to other processors are just a bit
slower if the hypertransport link is not saturated</tt></td>
</tr>
<tr class="c2">
<td><tt>15:54.19</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(also; a common use of supercomputers isn't to
run one really really big app, but to run a bunch of sorta big
apps)</tt></td>
</tr>
<tr class="c2">
<td><tt>15:54.27</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>That's usually what I refer to by
NUMA</tt></td>
</tr>
<tr class="c2">
<td><tt>15:54.59</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>you're talking about hypertransport and how it
can facilitate numa, not numa</tt></td>
</tr>
<tr class="c2">
<td><tt>15:55.12</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hypertransport is just a fast
interconnect...</tt></td>
</tr>
<tr class="c2">
<td><tt>15:55.40</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>if the kernel is stupid about using it, it'll
'page fault' through to the other cpu's memory banks frequently...
no?</tt></td>
</tr>
<tr class="c2">
<td><tt>15:56.00</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>No, it doesn't page fault</tt></td>
</tr>
<tr class="c2">
<td><tt>15:56.04</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>It's a hardware solution :)</tt></td>
</tr>
<tr class="c2">
<td><tt>15:56.19</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>ok, *shrug* then they have both in
hw</tt></td>
</tr>
<tr class="c2">
<td><tt>15:56.26</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The hardware physically routes queries to the
memory of other processor banks</tt></td>
</tr>
<tr class="c2">
<td><tt>15:56.38</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>on an sgi altix, afaik, it's a fault and
request... and surprisingly fast</tt></td>
</tr>
<tr class="c2">
<td><tt>15:56.50</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>on mosix, it's a fault and request... and
depends on the interconnect</tt></td>
</tr>
<tr class="c2">
<td><tt>15:57.15</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hum</tt></td>
</tr>
<tr class="c2">
<td><tt>15:57.35</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>so it's an mmu hack that requires use of the
hw 'task' vectors?</tt></td>
</tr>
<tr class="c2">
<td><tt>15:57.49</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>&lt;-- not versed in hypertransport, is old
:)</tt></td>
</tr>
<tr class="c2">
<td><tt>15:58.33</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>The pages are assigned to other memory banks,
I guess it's managed as such by the MMU</tt></td>
</tr>
<tr class="c2">
<td><tt>15:59.10</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>well, you have to manage the memory location
by task... if the hw does that, you have to tell the hw when you're
in a certain task...</tt></td>
</tr>
<tr class="c2">
<td><tt>15:59.17</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(task as in intel speak for process)</tt></td>
</tr>
<tr class="c2">
<td><tt>15:59.20</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>It's just one big memory bank really, it's
just that processors are faster to access their local one</tt></td>
</tr>
<tr class="c2">
<td><tt>16:00.33</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(as in hypertransport, not
hyperthreading)</tt></td>
</tr>
<tr class="c2">
<td><tt>16:01.30</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hm, works on packets that're either flagged
"posted" (for uma and dma) or "nonposted" (for numa)...</tt></td>
</tr>
<tr class="c2">
<td><tt>16:08.25</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Perhaps proper management of the memory banks,
DMA?</tt></td>
</tr>
<tr class="c2">
<td><tt>16:09.11</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>not sure, lots of bit manipulation, probably
to make the bank/process association to retain coherency</tt></td>
</tr>
<tr class="c2">
<td><tt>16:10.06</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>linux has a metric assload more than fbsd,
mebbe that's why the single process run on a linux opteron outran
the same run on a fbsd opteron</tt></td>
</tr>
<tr class="c2">
<td><tt>16:10.59</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>ooh, damnit, now I wanna do kernel hacking to
improve the cpu and memory affinity on that quad opteron</tt></td>
</tr>
<tr class="c2">
<td><tt>16:11.28</tt></td>
<td><span class="c10"><tt>dtidrow</tt></span></td>
<td width="100%"><tt>heh</tt></td>
</tr>
<tr class="c2">
<td><tt>16:11.37</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I can't believe a NUMA system which would page
faults for every access, requesting the data before resuming the
instruction, could perform comparably to software fetching the data
in advance as one big chunk</tt></td>
</tr>
<tr class="c2">
<td><tt>16:11.39</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>stupid raytracer crap</tt></td>
</tr>
<tr class="c2">
<td><tt>16:12.00</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>well, the "page fault" may not call a cpu
interrupt, it may be completely hw abstracted and fast
*shrug*</tt></td>
</tr>
<tr class="c2">
<td><tt>16:12.48</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>but the os still has to manage the mmu *shrug*
it may just be that the interconnect keeps a duplicate copy of the
kernels notion of what memory resides where</tt></td>
</tr>
<tr class="c2">
<td><tt>16:13.10</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I see.</tt></td>
</tr>
<tr class="c2">
<td><tt>16:14.41</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(per ghz, opteron running 85k rays/sec, g5 at
45k, ia32 at 18k... damn)</tt></td>
</tr>
<tr class="c2">
<td><tt>16:15.57</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(well, one opteron was 85k, the other was
60k... r12k was 31k, usII was 30k, ia64 at 41k)</tt></td>
</tr>
<tr class="c2">
<td><tt>16:16.19</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>librt this is?</tt></td>
</tr>
<tr class="c2">
<td><tt>16:16.23</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>ja</tt></td>
</tr>
<tr class="c2">
<td><tt>16:16.49</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>the 64 intel amd64 (used to be called EMT or
something?) came in at 25k</tt></td>
</tr>
<tr class="c2">
<td><tt>16:17.24</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>oh, with the ia32, 18k for linux, 32k for
fbsd...</tt></td>
</tr>
<tr class="c2">
<td><tt>16:17.58</tt></td>
<td><span class="c10"><tt>dtidrow</tt></span></td>
<td width="100%"><tt>in other words, librt is optimized for
fbsd</tt></td>
</tr>
<tr class="c2">
<td><tt>16:18.06</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>these are all 'per ghz' on machines with
radically differnet cpu speeds and no attention paid to bus speeds
or anything, btw</tt></td>
</tr>
<tr class="c2">
<td><tt>16:18.22</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>well, on the opteron, linux came in at 85k
where fbsd was 60k</tt></td>
</tr>
<tr class="c2">
<td><tt>16:18.58</tt></td>
<td><span class="c10"><tt>dtidrow</tt></span></td>
<td width="100%"><tt>guess linux has the better memory management
inplementation on opteron</tt></td>
</tr>
<tr class="c2">
<td><tt>16:19.05</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>makes me think that it's not an artifact of
librt being optimized one way or another, but the OS... amd64 is
immature on amd64, but kickin' on ia32</tt></td>
</tr>
<tr class="c2">
<td><tt>16:19.27</tt></td>
<td><span class="c10"><tt>dtidrow</tt></span></td>
<td width="100%"><tt>fbsd, you mean?</tt></td>
</tr>
<tr class="c2">
<td><tt>16:19.35</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I think the memory mgmt is all an upfront hit
with pools being used, ...</tt></td>
</tr>
<tr class="c2">
<td><tt>16:19.37</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>er, yeah, sorry</tt></td>
</tr>
<tr class="c2">
<td><tt>16:19.52</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>amd: linux&gt;fbsd. ia32:
fbsd&gt;linux.</tt></td>
</tr>
<tr class="c2">
<td><tt>16:20.18</tt></td>
<td><span class="c10"><tt>dtidrow</tt></span></td>
<td width="100%"><tt>heh, another reason for me to get AMD 
:-)</tt></td>
</tr>
<tr class="c2">
<td><tt>16:20.36</tt></td>
<td><span class="c10"><tt>dtidrow</tt></span></td>
<td width="100%"><tt>anyway gotta head in to work - later
all...</tt></td>
</tr>
<tr class="c2">
<td><tt>16:20.41</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>later, dude</tt></td>
</tr>
<tr>
<td><tt>17:23.23</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad bobbens
(n=bobbens@84.16.237.134)</span></tt></td>
</tr>
<tr class="c2">
<td><tt>18:51.46</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>numa is an abstract idea, not a specific
implementation...</tt></td>
</tr>
<tr class="c2">
<td><tt>19:31.44</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Oh hrm. Erik, I briefly mentionned we debated
cluster architectures in an email, and he asks, what's your
"recommendation"? :)</tt></td>
</tr>
<tr class="c2">
<td><tt>19:32.02</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>I guess he means TCP/IP vs MPI vs NUMA-aware
pthreads</tt></td>
</tr>
<tr class="c2">
<td><tt>19:32.21</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>In the context, "he" being Mark</tt></td>
</tr>
<tr class="c2">
<td><tt>19:36.52</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>numa-aware pthreads is generally part of
single-image systems, not clustering .. otherwise saying "red vs
blue vs duckies"</tt></td>
</tr>
<tr class="c2">
<td><tt>19:37.52</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>Altix clusters, for example, have an unified
address space though, which means that NUMA-aware threads could
reasonably work</tt></td>
</tr>
<tr class="c2">
<td><tt>19:39.36</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>there are massive altix smp and clusters of
massive altix smp</tt></td>
</tr>
<tr class="c2">
<td><tt>19:40.14</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the clusters don't have a unified address
space, altix is cool because it's smp and not a cluster in
itself</tt></td>
</tr>
<tr class="c2">
<td><tt>19:40.51</tt></td>
<td><span class="c9"><tt>Maloeran</tt></span></td>
<td width="100%"><tt>All right, that clarifies the definitions. So
it's a 512 processors SMP NUMA system</tt></td>
</tr>
<tr class="c2">
<td><tt>19:41.07</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>yes</tt></td>
</tr>
<tr class="c2">
<td><tt>19:41.51</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>and that'll be quite a price tag at that size
to say the least</tt></td>
</tr>
<tr class="c2">
<td><tt>19:42.02</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>&lt;PROTECTED&gt;</tt></td>
</tr>
<tr class="c2">
<td><tt>19:42.26</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>pretty much only find those systems at HPC
assets (which ARL does happen to have, the MSRC)</tt></td>
</tr>
<tr class="c2">
<td><tt>19:42.34</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>altix is numa, not smp...</tt></td>
</tr>
<tr class="c2">
<td><tt>19:42.50</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>altix is numa and smp</tt></td>
</tr>
<tr class="c2">
<td><tt>19:43.14</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>meh, numa is a memory layout, not a cpu
scheduling layout, so *shrug*</tt></td>
</tr>
<tr class="c2">
<td><tt>19:43.59</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>but duckies, ... duckies are awesome</tt></td>
</tr>
<tr class="c2">
<td><tt>19:44.06</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(ever watch 'ze frank'?)</tt></td>
</tr>
<tr class="c2">
<td><tt>19:44.12</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>daily ;)</tt></td>
</tr>
<tr class="c2">
<td><tt>19:44.29</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ze frank</tt></td>
</tr>
<tr class="c2">
<td><tt>19:44.38</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ze frank is pretty awesome</tt></td>
</tr>
<tr class="c2">
<td><tt>19:45.15</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it's on my daily list, too, along with sbemail
and the comic page and smacksnot</tt></td>
</tr>
<tr class="c2">
<td><tt>19:46.01</tt></td>
<td><span class="c11"><tt>archivist</tt></span></td>
<td width="100%"><tt>hmm smacks not or smack snot</tt></td>
</tr>
<tr class="c2">
<td><tt>19:46.18</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>smack snot</tt></td>
</tr>
<tr class="c2">
<td><tt>19:46.25</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>aka crack rock</tt></td>
</tr>
<tr class="c2">
<td><tt>19:46.40</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>sometimes slashdot, by the unitiated or
sufficiently confused</tt></td>
</tr>
<tr class="c2">
<td><tt>19:50.14</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>Maloeran: maybe watch some of these for
starters:  <a href=
"http://www.zefrank.com/theshow/">http://www.zefrank.com/theshow/</a>
then click on "popular shows" on the left</tt></td>
</tr>
<tr class="c2">
<td><tt>19:50.54</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>heh, then blow a solid week watching the
entire archive *cough* O:-)</tt></td>
</tr>
<tr class="c2">
<td><tt>19:51.21</tt></td>
<td><span class="c11"><tt>archivist</tt></span></td>
<td width="100%"><tt>I wont be able to read slashdot without the
thought smack snot going through my head now</tt></td>
</tr>
<tr class="c2">
<td><tt>19:51.42</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>*bow*</tt></td>
</tr>
<tr class="c2">
<td><tt>19:52.03</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>that's a good thing, right? you'll be able to
do something productive, instead?</tt></td>
</tr>
<tr class="c2">
<td><tt>19:52.28</tt></td>
<td><span class="c11"><tt>archivist</tt></span></td>
<td width="100%"><tt>wot hell no</tt></td>
</tr>
<tr class="c2">
<td><tt>19:54.23</tt></td>
<td><span class="c12"><tt>CIA-5</tt></span></td>
<td width="100%"><tt>BRL-CAD: 03erikgreenwald *
10brlcad/misc/Makefile.defs: punty "depends" target</tt></td>
</tr>
<tr class="c2">
<td><tt>19:59.52</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>nothing :)</tt></td>
</tr>
<tr class="c2">
<td><tt>20:00.00</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>there'll be a bigarsed commit in a
few</tt></td>
</tr>
<tr class="c2">
<td><tt>20:00.19</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>hrm</tt></td>
</tr>
<tr class="c2">
<td><tt>20:00.22</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>but, as the regex.h issue remains, my testing
of it is incomplete</tt></td>
</tr>
<tr class="c2">
<td><tt>20:01.09</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I don't think tcl's regex stuff can be easily
removed, it looks like it's use in the symbol resolving functions,
as well as in the file routines</tt></td>
</tr>
<tr class="c2">
<td><tt>20:03.38</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i didn't mean remove the regex code, just the
files themselves -- or do you mean they're #including .c files or
something?</tt></td>
</tr>
<tr class="c2">
<td><tt>20:04.03</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>&lt;-- finds himself going into dirs in the
appropriate dep chain order and doing make by hand to get the lib
or bin he wants, thinks it'd be keen if he could go where he wants
and do "make depends all"</tt></td>
</tr>
<tr class="c2">
<td><tt>20:04.20</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ahh</tt></td>
</tr>
<tr class="c2">
<td><tt>20:04.23</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>yeah, that would be useful</tt></td>
</tr>
<tr class="c2">
<td><tt>20:04.31</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>not including .c files, but generic/regex.h is
used several places in generic/*.c</tt></td>
</tr>
<tr class="c2">
<td><tt>20:04.34</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i do the cd dir dir dir blah foo too</tt></td>
</tr>
<tr class="c2">
<td><tt>20:05.14</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i think only folks that understand how
automake works are generally inclined to do that, but hey that's
cool</tt></td>
</tr>
<tr class="c2">
<td><tt>20:05.18</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>it might be best to mv regex.h regex_tcl.h and
sed 's/regex\.h/regex_tcl.h' *.[ch]</tt></td>
</tr>
<tr class="c2">
<td><tt>20:05.38</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>might also just get away with
-DVOID=void</tt></td>
</tr>
<tr class="c2">
<td><tt>20:05.52</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I'd do it to what we have now, but I ASSUME
you're close to committing a new tcl</tt></td>
</tr>
<tr class="c2">
<td><tt>20:05.57</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the more I looked at it last night, the more
it looked like it was empty</tt></td>
</tr>
<tr class="c2">
<td><tt>20:05.59</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>that won't be the only thing broken, just the
first</tt></td>
</tr>
<tr>
<td><tt>20:06.20</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad clock_
(i=clock@84-72-63-61.dclient.hispeed.ch)</span></tt></td>
</tr>
<tr class="c2">
<td><tt>20:06.31</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>unless generic/regex.h just happens to have
all the meat of /usr/include/regex.h and it happens to use the same
define values and stuff</tt></td>
</tr>
<tr class="c2">
<td><tt>20:07.21</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>well, commit it up, yo... even if it's busted,
we could split the load and both go about fixing...
*shrug*</tt></td>
</tr>
<tr class="c2">
<td><tt>20:11.36</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>in a branch if ya want *shrug* I'll sync to a
branch</tt></td>
</tr>
<tr class="c2">
<td><tt>20:13.46</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>commit what up?</tt></td>
</tr>
<tr class="c2">
<td><tt>20:13.59</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>-DVOID=void?</tt></td>
</tr>
<tr class="c2">
<td><tt>20:14.48</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>still working on finishing this 8.5
testing/building, trying to get subconfigures to work
reliably</tt></td>
</tr>
<tr class="c2">
<td><tt>20:17.07</tt></td>
<td><span class="c5"><tt>dtidrow_work</tt></span></td>
<td width="100%"><tt><a href=
"http://tinyurl.com/3cx56e">http://tinyurl.com/3cx56e</a> - good
grief</tt></td>
</tr>
<tr class="c2">
<td><tt>20:17.39</tt></td>
<td><span class="c5"><tt>dtidrow_work</tt></span></td>
<td width="100%"><tt>the excessively accesorised toilet</tt></td>
</tr>
<tr class="c2">
<td><tt>20:19.12</tt></td>
<td><span class="c11"><tt>archivist</tt></span></td>
<td width="100%"><tt>lacks a lectern for a heavy book</tt></td>
</tr>
<tr class="c2">
<td><tt>20:19.24</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>hrm.. by that math</tt></td>
</tr>
<tr class="c2">
<td><tt>20:22.09</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it's saying the average person spends 11862
hours per day in the bathroom (presumably on the toilet) .. which
is roughly 30 minutes a day</tt></td>
</tr>
<tr class="c2">
<td><tt>20:22.58</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>per day?</tt></td>
</tr>
<tr class="c2">
<td><tt>20:23.31</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>heh</tt></td>
</tr>
<tr class="c2">
<td><tt>20:24.02</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i know some people that .. er .. take forever,
but then they have "issues" too afaik</tt></td>
</tr>
<tr class="c2">
<td><tt>20:24.16</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>well yeah, that depends what all is
included</tt></td>
</tr>
<tr class="c2">
<td><tt>20:24.28</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>the article makes it sound like you spend all
that time on the john</tt></td>
</tr>
<tr class="c2">
<td><tt>20:25.05</tt></td>
<td><span class="c5"><tt>dtidrow_work</tt></span></td>
<td width="100%"><tt>heh - women spend at least 1.5hrs a day in the
bathroom, then</tt></td>
</tr>
<tr class="c2">
<td><tt>20:25.06</tt></td>
<td><span class="c11"><tt>archivist</tt></span></td>
<td width="100%"><tt>for a good stiff sh.. the a good read is
needed</tt></td>
</tr>
<tr class="c2">
<td><tt>20:26.45</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i never got that, i'm in and out every time --
there's no by the time I finish a couple sentances, it's
over</tt></td>
</tr>
<tr class="c2">
<td><tt>20:27.16</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>need something to tear pages out of if there's
no tp *shrug*</tt></td>
</tr>
<tr class="c2">
<td><tt>20:28.13</tt></td>
<td><span class="c5"><tt>dtidrow_work</tt></span></td>
<td width="100%"><tt>clearly ``Erik belongs to the church of
vi</tt></td>
</tr>
<tr class="c2">
<td><tt>20:28.24</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>yes, the vim sect</tt></td>
</tr>
<tr class="c2">
<td><tt>20:31.05</tt></td>
<td><span class="c12"><tt>CIA-5</tt></span></td>
<td width="100%"><tt>BRL-CAD: 03erikgreenwald * 10brlcad/src/ (13
files in 13 dirs): beginnings of DEPS flags for "make depends"
chaining.</tt></td>
</tr>
<tr class="c2">
<td><tt>20:46.34</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ahh</tt></td>
</tr>
<tr class="c2">
<td><tt>20:48.28</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>?</tt></td>
</tr>
<tr class="c2">
<td><tt>20:49.47</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>instead of (re)listing the dependencies..
they're already listed in a couple places</tt></td>
</tr>
<tr class="c2">
<td><tt>20:50.27</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>you could parse over the libadd/ldadd stuff,
or peek at the _DEPENDENCIES vars or peek in the .deps dirs and
build up that directory list automatically</tt></td>
</tr>
<tr class="c2">
<td><tt>20:51.08</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>so you don't have to maintain a separate list
that'll eventually be out of sync when someone adds a new lib and
doesn't notice the DEPS var</tt></td>
</tr>
<tr class="c2">
<td><tt>20:51.29</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it'd always be perfectly in sync</tt></td>
</tr>
<tr class="c2">
<td><tt>20:51.39</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>spoze I coulda tried that, and did sed-fu to
strip it down *shrug* but if I did that, then people who're
over-verbose in attaching libraries would cause a LOT of duplicate
computation</tt></td>
</tr>
<tr class="c2">
<td><tt>20:52.16</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>&lt;-- already annoyed with the amount of
replication of computation with the hand-minimized list</tt></td>
</tr>
<tr class="c2">
<td><tt>20:53.22</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>replication?</tt></td>
</tr>
<tr class="c2">
<td><tt>20:54.56</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>yeah... if I do 'make depends' in, say,
mged... rt-&gt;bn-&gt;bu-&gt;tcl, tk-&gt;tcl, so tcl gets two
passes</tt></td>
</tr>
<tr class="c2">
<td><tt>20:54.58</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>if you need to rebuild mged and be portably
sure, it's got to walk the dependency hierarchy for each ldadd lib
..</tt></td>
</tr>
<tr class="c2">
<td><tt>20:55.28</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>hmm.. sounds like you need to build up the
list of what to do before actually doing it</tt></td>
</tr>
<tr class="c2">
<td><tt>20:55.38</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I was half tempted to give each dir an "am I
built?" target and stopping if that's yes</tt></td>
</tr>
<tr class="c2">
<td><tt>20:56.00</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>that's one way, but to be portable across
makes, ... :/</tt></td>
</tr>
<tr class="c2">
<td><tt>20:56.56</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>sure across makes</tt></td>
</tr>
<tr class="c2">
<td><tt>20:56.56</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>you do the same traversal you have in depends
now .. but make it do two walks .. just not runnning depends on the
first walk</tt></td>
</tr>
<tr class="c2">
<td><tt>20:57.52</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>mebbe in the future...</tt></td>
</tr>
<tr class="c2">
<td><tt>20:58.39</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>it is, but the hooks they provide should make
it work</tt></td>
</tr>
<tr class="c2">
<td><tt>20:58.47</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i fixed a handful of things, there still
another problem?</tt></td>
</tr>
<tr class="c2">
<td><tt>20:58.59</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>could have disabled more, but I tried to only
disable minimal</tt></td>
</tr>
<tr class="c2">
<td><tt>20:59.07</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>how'd you disable it?</tt></td>
</tr>
<tr class="c2">
<td><tt>20:59.31</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>Makefile.am cppflags to turn stuff
on/off</tt></td>
</tr>
<tr class="c2">
<td><tt>21:00.05</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>right</tt></td>
</tr>
<tr class="c2">
<td><tt>21:00.15</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>i commited a fix for that yesterday</tt></td>
</tr>
<tr class="c2">
<td><tt>21:00.18</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>libdm/dm_obj.c</tt></td>
</tr>
<tr class="c2">
<td><tt>21:00.25</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>I updated today, it's still breakin'
O.o</tt></td>
</tr>
<tr class="c2">
<td><tt>21:00.27</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>at least I thought I did</tt></td>
</tr>
<tr class="c2">
<td><tt>21:00.43</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>(also don't remember seeing a cia
msg)</tt></td>
</tr>
<tr class="c2">
<td><tt>21:01.19</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>huh, that's odd</tt></td>
</tr>
<tr class="c2">
<td><tt>21:02.05</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>hrm, maybe the commit errored/timed out and I
didn't notice</tt></td>
</tr>
<tr class="c2">
<td><tt>21:03.58</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>ahh, yeah, something happened</tt></td>
</tr>
<tr class="c2">
<td><tt>21:03.59</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>M pngconf.h</tt></td>
</tr>
<tr class="c2">
<td><tt>21:04.17</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>probably queried for a pass and I didn't
notice or something</tt></td>
</tr>
<tr class="c2">
<td><tt>21:06.29</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>that's the included png... I'm trying to use
the system png</tt></td>
</tr>
<tr class="c2">
<td><tt>21:07.14</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>like guard the setjmp in bu.h and make sure
png.h is included before bu.h</tt></td>
</tr>
<tr class="c2">
<td><tt>21:07.27</tt></td>
<td><span class="c12"><tt>CIA-5</tt></span></td>
<td width="100%"><tt>BRL-CAD: 03brlcad *
10brlcad/src/other/libpng/pngconf.h: disable the linux setjmp.h
double-inclusion protection (at least for now) on the assumption
that we will get the same setjmp.h and this won't be a problem. add
a note that this was modified by us for BRL-CAD.</tt></td>
</tr>
<tr class="c2">
<td><tt>21:07.38</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>since the png fucktards can't figure out how
to guard headers right *cougH*</tt></td>
</tr>
<tr class="c2">
<td><tt>21:07.46</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>pngconf.h is installed on the
system?</tt></td>
</tr>
<tr class="c2">
<td><tt>21:08.03</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>yes$ ls -l /usr/include/pngconf.h</tt></td>
</tr>
<tr class="c2">
<td><tt>21:08.03</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>lrwxrwxrwx  1 root root 18 Aug 11 12:34
/usr/include/pngconf.h -&gt; libpng12/pngconf.h</tt></td>
</tr>
<tr class="c2">
<td><tt>21:08.24</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>rhel64 on an opteron</tt></td>
</tr>
<tr class="c2">
<td><tt>21:08.47</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>shuffling headers and gaurding in bu.h sound
about right? I can take care of it while you do tcl</tt></td>
</tr>
<tr class="c2">
<td><tt>21:09.05</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>could work it out so that png.h is just
included before our stuff -- it should be actually</tt></td>
</tr>
<tr class="c2">
<td><tt>21:09.13</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>'k, I'll go about that</tt></td>
</tr>
<tr class="c2">
<td><tt>21:09.17</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>hurry up and finish tcl :D</tt></td>
</tr>
<tr class="c2">
<td><tt>21:09.32</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>common.h -&gt; system headers -&gt; public
interface headers -&gt; private headers</tt></td>
</tr>
<tr class="c2">
<td><tt>21:09.37</tt></td>
<td><span class="c6"><tt>``Erik</tt></span></td>
<td width="100%"><tt>so i can unhack regionfix.c and proe-g.c on my
thing</tt></td>
</tr>
<tr class="c2">
<td><tt>21:09.42</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>png.h is a system header</tt></td>
</tr>
<tr class="c2">
<td><tt>21:10.18</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>another fix would be to just set
-DPNG_SETJMP_NOT_SUPPORTED</tt></td>
</tr>
<tr class="c2">
<td><tt>21:10.31</tt></td>
<td><span class="c1"><tt>brlcad</tt></span></td>
<td width="100%"><tt>and it skips it altogether</tt></td>
</tr>
<tr class="c2">
<td><tt>21:12.13</tt></td>
<td><span class="c12"><tt>CIA-5</tt></span></td>
<td width="100%"><tt>BRL-CAD: 03erikgreenwald *
10brlcad/src/libdm/dm_obj.c: pull system headers up ahead of our
headers</tt></td>
</tr>
<tr class="c2">
<td><tt>21:14.24</tt></td>
<td><span class="c12"><tt>CIA-5</tt></span></td>
<td width="100%"><tt>BRL-CAD: 03erikgreenwald *
10brlcad/src/canon/png-ipu.c: pull system headers up ahead of our
headers</tt></td>
</tr>
<tr>
<td><tt>22:02.23</tt></td>
<td colspan="2"><tt><span class="c8">*** join/#brlcad dtidrow
(n=dtidrow@c-69-255-182-248.hsd1.va.comcast.net) [NETSPLIT
VICTIM]</span></tt></td>
</tr>
<tr class="c2">
<td><tt>23:37.14</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>more</tt></td>
</tr>
<tr class="c2">
<td><tt>23:37.20</tt></td>
<td><span class="c4"><tt>louipc</tt></span></td>
<td width="100%"><tt>erk</tt></td>
</tr>
</table>
<br />
Generated by irclog2html.pl by <a href=
"mailto:jdub@NOSPAMaphid.net">Jeff Waugh</a> - find it at <a href=
"http://freshmeat.net/appindex/2000/03/28/954251322.html">freshmeat.net</a>!
Modified by <a href="http://www.Rikers.org">Tim Riker</a> to work
with <a href="http://blootbot.sourceforge.net/">blootbot</a> logs,
split per channel, etc.
</body>
</html>
